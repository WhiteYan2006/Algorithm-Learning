---
date: 2025-09-26
tags:
  - 编程
  - 数据结构
  - 链表
  - Cpp
  - 习题
---
# 链表（List）

## 1. 什么是链表
与数组的核心区别在于内存存储方式，是理解链表特性的关键：
- 数组：内存中**连续的一段空间**，通过索引可直接定位元素（随机访问）。
- 链表：内存中**散列的独立空间**，通过「指针」将各个空间（结点）连接成逻辑上的线性结构。


## 2. 链表的结构
链表由「结点（Node）」构成，实际开发/刷题中常直接操作结点（而非封装后的容器），核心是记录关键结点（头、尾）。

### 2.1 单链表结点定义（模板）
```cpp
template<typename T>
struct Node {
    T val;          // 结点存储的值
    Node* next;     // 指向下一个结点的指针，默认初始化为 nullptr
};
```

### 2.2 核心概念
- **指针**：表示当前结点指向的下一个结点地址，是链表连接的核心。
- **结点**：最小数据单元，包含「数据（val）」和「指针（next）」。
- **头结点（head）**：链表的第一个有效结点，是遍历/操作的起始点。
- **尾结点（tail）**：链表的最后一个有效结点，其`next`指针指向`nullptr`。


## 3. 链表的基础操作（单链表）
### 3.1 遍历整个链表
遍历是链表操作的基础，通过指针逐结点移动，时间复杂度$O(n)$。
```cpp
// 传入头结点，计算链表元素和、长度
void traversal(Node<T>* head) {
    int sum = 0;
    int len = 0;
    // cur 从 head 开始，直到 null（尾结点的 next）结束
    for (Node<T>* cur = head; cur != nullptr; cur = cur->next) {
        sum += cur->val;
        len ++;
    }
    cout << "链表元素和：" << sum << endl;
    cout << "链表长度：" << len << endl;
}
```

### 3.2 获取链表长度
本质是遍历的简化，返回当前结点到尾结点的距离。
```cpp
int getLength(Node<T>* head) {
    int len = 0;
    for (Node<T>* cur = head; cur != nullptr; cur = cur->next) {
        len ++;
    }
    return len;
}
```

### 3.3 在某个结点后插入新结点
插入需保证「先连后断」，避免指针丢失（核心易错点）。
```cpp
// 在 cur 结点后插入值为 x 的新结点
void insertAfter(Node<T>* cur, T x) {
    // 1. 创建新结点，初始化值和指针
    Node<T>* newNode = new Node<T>{x, nullptr};
    // 2. 先让新结点指向 cur 的下一个结点（保存原后续关系）
    newNode->next = cur->next;
    // 3. 再让 cur 指向新结点（更新 cur 的后续关系）
    cur->next = newNode;
}
```

### 3.4 删除某个结点的后一个结点
删除前需判断「待删结点是否存在」，避免空指针访问。
```cpp
// 删除 cur 结点的下一个结点
void eraseAfter(Node<T>* cur) {
    // 边界判断：cur 的下一个结点为空，无需删除
    if (cur->next == nullptr) return;
    // 直接让 cur 跳过下一个结点，指向更后续的结点
    cur->next = cur->next->next;
    // （可选）若需释放内存，需先保存待删结点地址，删除后再置空
    // Node<T>* temp = cur->next;
    // cur->next = temp->next;
    // delete temp;
    // temp = nullptr;
}
```


## 4. 双向链表（解决单链表的缺陷）
### 4.1 单链表的痛点
无法直接删除某个指定结点——因为不知道该结点的「前驱结点」，无法更新前驱的`next`指针。

### 4.2 双向链表结点定义
增加`prev`指针，记录前驱结点地址，解决单链表痛点：
```cpp
template<typename T>
struct DoubleNode {
    T val;               // 结点值
    DoubleNode* prev;    // 指向前驱结点
    DoubleNode* next;    // 指向后继结点
};
```

### 4.3 双向链表的核心操作
#### 4.3.1 直接删除指定结点
无需遍历找前驱，通过`prev`指针直接定位，时间复杂度$O(1)$：
```cpp
void eraseNode(DoubleNode<T>* node) {
    // 1. 获取前驱和后继结点
    DoubleNode<T>* prevNode = node->prev;
    DoubleNode<T>* nextNode = node->next;
    // 2. 更新前驱的 next 指针（若前驱存在）
    if (prevNode != nullptr) {
        prevNode->next = nextNode;
    }
    // 3. 更新后继的 prev 指针（若后继存在）
    if (nextNode != nullptr) {
        nextNode->prev = prevNode;
    }
    // 4. 释放当前结点内存
    delete node;
    node = nullptr;
}
```

#### 4.3.2 在指定结点后插入新结点
需同时维护`prev`和`next`指针的双向关系：
```cpp
void insertAfter(DoubleNode<T>* cur, T x) {
    // 1. 获取 cur 的后继结点
    DoubleNode<T>* nextNode = cur->next;
    // 2. 创建新结点，初始化 prev 和 next
    DoubleNode<T>* newNode = new DoubleNode<T>{x, cur, nextNode};
    // 3. 更新 cur 的后继指针
    cur->next = newNode;
    // 4. 若后继存在，更新其后继的前驱指针
    if (nextNode != nullptr) {
        nextNode->prev = newNode;
    }
}
```


## 5. Dummy 结点（哨兵节点）—— 简化边界处理
### 5.1 链表的边界痛点
操作头/尾结点时（如删除头结点、在头结点前插入），会导致`head`/`tail`指针改变，需额外判断，代码冗余且易出错；若链表为空，插入元素时无明确「挂载点」。

### 5.2 Dummy 结点的作用
- **定义**：一个「无实际意义」的虚拟结点，始终存在（即使链表为空）。
- **核心价值**：用`dummy_head->next`代替原`head`，用`dummy_tail->prev`代替原`tail`，统一所有结点的操作逻辑（无需区分头/尾/空链表）。

### 5.3 关键特性
- Dummy 结点不存储有效数据，不参与业务逻辑计算。
- 无论链表是否为空，Dummy 结点始终存在，避免「空指针挂载」问题。


## 6. 链表设计实战（模板题）
### 6.1 LeetCode 707. 设计链表（双向链表 + Dummy 结点）
```cpp
class MyLinkedList {
private:
    // 定义双向链表结点
    struct Node {
        int val;
        Node* prev;
        Node* next;
        Node(int x) : val(x), prev(nullptr), next(nullptr) {}
    };
    
    Node* dummy;  // Dummy 头结点（简化边界处理）
    Node* tail;   // 尾结点（优化尾插效率）
    int size;     // 链表长度（避免频繁遍历计数）

    // 辅助函数：获取索引为 index 的结点（越界返回 nullptr）
    Node* getNode(int index) {
        if (index < 0 || index >= size) return nullptr;
        Node* cur = dummy->next;
        for (int i = 0; i < index; ++i) {
            cur = cur->next;
        }
        return cur;
    }

public:
    // 初始化：Dummy 结点存在，链表为空
    MyLinkedList() {
        dummy = new Node(0);
        tail = dummy;
        size = 0;
    }
    
    // 获取索引 index 处的值（越界返回 -1）
    int get(int index) {
        Node* cur = getNode(index);
        return cur ? cur->val : -1;
    }
    
    // 在头部插入值 val
    void addAtHead(int val) {
        Node* head = dummy->next;  // 原头结点
        Node* newNode = new Node(val);
        
        // 维护双向指针
        newNode->prev = dummy;
        newNode->next = head;
        dummy->next = newNode;
        if (head != nullptr) {
            head->prev = newNode;
        } else {
            // 原链表为空，新结点即为尾结点
            tail = newNode;
        }
        size++;
    }
    
    // 在尾部插入值 val
    void addAtTail(int val) {
        Node* newNode = new Node(val);
        // 尾结点的 next 指向新结点，新结点的 prev 指向尾结点
        tail->next = newNode;
        newNode->prev = tail;
        // 更新尾结点为新结点
        tail = newNode;
        size++;
    }
    
    // 在索引 index 处插入值 val（越界不操作）
    void addAtIndex(int index, int val) {
        if (index > size) return;
        // 索引等于长度，等价于尾插
        if (index == size) {
            addAtTail(val);
            return;
        }
        // 找到插入位置的结点
        Node* cur = getNode(index);
        Node* prevNode = cur->prev;
        Node* newNode = new Node(val);
        
        // 维护双向指针
        newNode->prev = prevNode;
        newNode->next = cur;
        prevNode->next = newNode;
        cur->prev = newNode;
        size++;
    }
    
    // 删除索引 index 处的结点（越界不操作）
    void deleteAtIndex(int index) {
        Node* cur = getNode(index);
        if (cur == nullptr) return;
        
        Node* prevNode = cur->prev;
        Node* nextNode = cur->next;
        
        // 维护双向指针
        prevNode->next = nextNode;
        if (nextNode != nullptr) {
            nextNode->prev = prevNode;
        } else {
            // 待删结点是尾结点，更新尾结点为前驱
            tail = prevNode;
        }
        
        // 释放内存
        delete cur;
        size--;
    }
};
```

### 6.2 洛谷 B4324 【模板】双向链表（数组模拟链表）
```cpp
struct List {
    // 结点结构（用数组模拟指针，避免动态内存开销）
    struct Node {
        int val;
        Node* next;
        Node* prev;
    };

    vector<Node*> nodes;  // 存储所有结点的地址
    vector<int> inList;   // 标记结点是否在链表中（1=在，0=不在）
    int n;                // 初始结点总数

    // 初始化：创建 n 个结点，并连成双向链表
    List(int n) : n(n) {
        inList.resize(n + 1, 1);  // 结点编号 1~n
        nodes.resize(n + 1);

        // 创建所有结点
        for (int i = 0; i <= n; ++i) {
            nodes[i] = new Node{i, nullptr, nullptr};
        }

        // 连接成双向链表（0 作为 dummy 头结点）
        for (int i = 0; i <= n; ++i) {
            if (i != 0) nodes[i]->prev = nodes[i - 1];
            if (i != n) nodes[i]->next = nodes[i + 1];
        }
    }

    // 辅助函数：将 x 结点从链表中移除（不删除内存）
    Node* removeFromList(int x) {
        if (!inList[x]) return nullptr;
        Node* cur = nodes[x];
        Node* prevNode = cur->prev;
        Node* nextNode = cur->next;

        // 维护前后结点的指针
        prevNode->next = nextNode;
        if (nextNode != nullptr) {
            nextNode->prev = prevNode;
        }

        inList[x] = 0;  // 标记为不在链表中
        return cur;
    }

    // 在 y 结点前插入 x 结点
    void insertBefore(int x, int y) {
        if (x == y || !inList[x] || !inList[y]) return;
        Node* X = removeFromList(x);
        Node* Y = nodes[y];
        Node* prevY = Y->prev;

        // 连接 X 与前后结点
        prevY->next = X;
        X->prev = prevY;
        X->next = Y;
        Y->prev = X;

        inList[x] = 1;  // 标记为在链表中
    }

    // 在 y 结点后插入 x 结点
    void insertAfter(int x, int y) {
        if (x == y || !inList[x] || !inList[y]) return;
        Node* X = removeFromList(x);
        Node* Y = nodes[y];
        Node* nextY = Y->next;

        // 连接 X 与前后结点
        if (nextY != nullptr) nextY->prev = X;
        X->next = nextY;
        X->prev = Y;
        Y->next = X;

        inList[x] = 1;  // 标记为在链表中
    }

    // 彻底删除 x 结点（从内存中释放）
    void remove(int x) {
        Node* node = removeFromList(x);
        delete node;
        inList[x] = 0;
    }

    // 输出链表（从 dummy 头结点的 next 开始）
    void output() {
        if (nodes[0]->next == nullptr) {
            cout << "Empty!" << endl;
            return;
        }
        for (Node* cur = nodes[0]->next; cur != nullptr; cur = cur->next) {
            cout << cur->val << " ";
        }
        cout << endl;
    }
};
```


## 7. 链表高频面试题
| 题目链接 | 核心考点 |
|----------|----------|
| [LeetCode 19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/) | 双指针（快慢指针）、Dummy 结点 |
| [LeetCode 24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/) | 指针操作、递归/迭代 |
| [LeetCode 61. 旋转链表](https://leetcode.cn/problems/rotate-list/) | 链表成环、找新头/尾 |
| [LeetCode 83. 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/) | 遍历去重、指针跳过 |
| [LeetCode 82. 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/) | Dummy 结点、重复结点批量删除 |
| [LeetCode 86. 分隔链表](https://leetcode.cn/problems/partition-list/) | 拆分链表、合并链表 |
| [LeetCode 141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/) | 双指针（快慢指针）、哈希表 |
| [LeetCode 92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/) | 局部反转、指针记录 |
| [LeetCode 25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/) | 批量反转、递归/迭代 |

## 8. 链表的实际应用
### 8.1 LRU 缓存（Least Recently Used，最近最少使用）
#### 8.1.1 缓存的核心问题
缓存空间有限，需决定「保留哪些数据、淘汰哪些数据」，LRU 是经典淘汰策略。

#### 8.1.2 LRU 原理（基于双向链表）
将缓存数据视为「有序链表」，遵循以下规则：
- **新数据/被访问的旧数据**：移到链表头部（标记为「最近使用」）。
- **缓存满时**：删除链表尾部数据（标记为「最少使用」）。

#### 8.1.3 对应题目
[LeetCode 146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)（需结合哈希表优化查找效率，时间复杂度$O(1)$）。

### 8.2 内存池（解决频繁 new/delete 的开销问题）
#### 8.2.1 频繁 new/delete 的痛点
- 速度慢：单次 new/delete 需操作系统分配/回收内存，1000w 次 new 远慢于 1 次 new 1000w 长度数组。
- 内存碎片：频繁分配/回收会导致内存空间碎片化，进一步降低程序效率。

#### 8.2.2 内存池原理
预先申请一块「超大连续内存」作为「池」，后续操作在池内完成：
- 申请内存（new）：从池中直接分配，无需调用系统接口。
- 释放内存（delete）：将内存归还给池，而非直接还给系统。

#### 8.2.3 内存池实现（模板）
```cpp
template <typename T>
class ObjectPool {
private:
    T* pool;               // 预先申请的内存池
    vector<T*> freeList;   // 记录池中的空闲内存地址

public:
    // 构造函数：初始化内存池（容量为 cap）
    ObjectPool(size_t cap) {
        // 用 malloc 申请内存（避免触发 T 的默认构造，减少开销）
        pool = (T*)(malloc(cap * sizeof(T)));
        freeList.reserve(cap);  // 预留空间，避免扩容

        // 将池中的内存地址依次加入空闲列表
        for (size_t i = 0; i < cap; ++i) {
            freeList.push_back(pool + i);
        }
    }

    // 析构函数：释放内存池（需先析构活跃对象）
    ~ObjectPool() {
        // TODO：若 T 有自定义析构函数，需先遍历活跃对象调用析构
        free(pool);  // 释放整个内存池
    }

    // 分配内存（类比 new，支持带参数的构造）
    template <typename... Args>
    T* allocate(Args&&... args) {
        if (freeList.empty()) {
            throw bad_alloc{};  // 内存池耗尽，可扩展逻辑（动态扩容）
        }
        // 从空闲列表尾部取地址（O(1)）
        T* addr = freeList.back();
        freeList.pop_back();
        // 原地构造：在 addr 地址上初始化 T 对象（不申请新内存）
        return new (addr) T(forward<Args>(args)...);
    }

    // 释放内存（类比 delete）
    void deallocate(T* ptr) {
        if (!ptr) return;
        // 显式调用 T 的析构函数（释放对象资源）
        ptr->~T();
        // 将内存地址归还给空闲列表
        freeList.push_back(ptr);
    }
};
```


## 9. 链表的竞赛用法（数组模拟链表）
### 9.1 竞赛场景特点
- 数据量小（通常$\leq 10^7$），无需考虑内存回收。
- 追求速度：避免动态内存分配（new/delete）的开销，用数组模拟指针。

### 9.2 实现思路
- 用`nxt`数组模拟「next 指针」，`pre`数组模拟「prev 指针」，`val`数组存储结点值。
- 用`sz`（或`index`）记录当前可用的数组下标（类比「内存池的空闲地址」）。

### 9.3 代码模板
```cpp
const int MAX_N = 1e5 + 10;  // 根据题目数据量调整

// 数组模拟指针：nxt[i] 表示第 i 个结点的 next 指针
vector<int> nxt(MAX_N, -1), pre(MAX_N, -1);
vector<int> val(MAX_N, -1);  // 存储结点值
int sz = 0;  // 当前可用的数组下标（初始为 0，每次新建结点后自增）

// 新建结点（类比 new）：返回结点的数组下标（即「指针」）
int newNode(int v, int prevIdx, int nextIdx) {
    val[sz] = v;
    pre[sz] = prevIdx;
    nxt[sz] = nextIdx;
    return sz++;  // 返回当前下标，后自增
}

// 初始化链表（头、尾结点为 dummy 结点）
using Ptr = int;  // 用 int 表示「指针」（即数组下标）
Ptr dummyHead = newNode(0, -1, -1);  // dummy 头结点
Ptr dummyTail = newNode(0, -1, -1);  // dummy 尾结点
nxt[dummyHead] = dummyTail;          // 连接 dummy 头和尾
pre[dummyTail] = dummyHead;

// 遍历链表（从 dummyHead 的 next 到 dummyTail）
for (Ptr cur = nxt[dummyHead]; cur != dummyTail; cur = nxt[cur]) {
    // 操作当前结点：val[cur] 即为结点值
    cout << val[cur] << " ";
}
```

### 9.4 竞赛对应题目
| 题目链接                                                                                        | 核心考点        |
| ------------------------------------------------------------------------------------------- | ----------- |
| [洛谷 P1996 约瑟夫问题](https://www.luogu.com.cn/problem/P1996)                                    | 循环链表、模拟淘汰   |
| [洛谷 P12166 冷热数据队列](https://www.luogu.com.cn/problem/P12166)                                 | 双向链表、数据优先级  |
| [洛谷 P12085 整数删除](https://www.luogu.com.cn/problem/P12085)                                   | 数组模拟链表、快速删除 |
| [洛谷 P7912 小熊的果篮](https://www.luogu.com.cn/problem/P7912)                                    | 链表遍历、条件删除   |
| [AtCoder ABC421 F Erase between X and Y](https://atcoder.jp/contests/abc421/tasks/abc421_f) | 双向链表、区间删除   |



# 习题
## 设计链表-LeetCode707
### 题目说明
你可以选择使用单链表或者双链表，设计并实现自己的链表。

单链表中的节点应该具备两个属性：`val` 和 `next` 。`val` 是当前节点的值，`next` 是指向下一个节点的指针/引用。

如果是双向链表，则还需要属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点下标从 **0** 开始。

实现 `MyLinkedList` 类：

- `MyLinkedList()` 初始化 `MyLinkedList` 对象。
- `int get(int index)` 获取链表中下标为 `index` 的节点的值。如果下标无效，则返回 `-1` 。
- `void addAtHead(int val)` 将一个值为 `val` 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。
- `void addAtTail(int val)` 将一个值为 `val` 的节点追加到链表中作为链表的最后一个元素。
- `void addAtIndex(int index, int val)` 将一个值为 `val` 的节点插入到链表中下标为 `index` 的节点之前。如果 `index` 等于链表的长度，那么该节点会被追加到链表的末尾。如果 `index` 比长度更大，该节点将 **不会插入** 到链表中。
- `void deleteAtIndex(int index)` 如果下标有效，则删除链表中下标为 `index` 的节点。

**示例：**

**输入**
["MyLinkedList", "addAtHead", "addAtTail", "addAtIndex", "get", "deleteAtIndex", "get"]
[[], [1], [3], [1, 2], [1], [1], [1]]
**输出**
[null, null, null, null, 2, null, 3]

**解释**
MyLinkedList myLinkedList = new MyLinkedList();
myLinkedList.addAtHead(1);
myLinkedList.addAtTail(3);
myLinkedList.addAtIndex(1, 2);    // 链表变为 1->2->3
myLinkedList.get(1);              // 返回 2
myLinkedList.deleteAtIndex(1);    // 现在，链表变为 1->3
myLinkedList.get(1);              // 返回 3
### 双向链表实现
```C++
class MyLinkedList {
public:
    struct Node {
        int val;
        Node *prev, *next;
    };
    Node *dummy_head, *dummy_tail;
    int size;

    Node* at(int index) { //根据下标获取元素
        if(index >= size || index < 0)  return nullptr;
        Node* cur = dummy_head->next;
        while(index--) cur = cur->next;
        return cur;
    }
    MyLinkedList() {
        dummy_head = new Node(0,nullptr,nullptr);
        dummy_tail = new Node(0,dummy_head,nullptr);
        dummy_head->next = dummy_tail;
        size = 0;
    }

    int get(int index) {
        Node* cur = at(index);
        if (cur == nullptr) return -1;
        return cur->val;
    }

    void addAtHead(int val) {
        Node* first = dummy_head->next;
        Node* new_node = new Node(val, dummy_head, first);
        first->prev = new_node;
        dummy_head->next = new_node;
        size++; // 不要忘记size++
    }

    void addAtTail(int val) {
        Node* last = dummy_tail->prev;
        Node* new_node = new Node(val, last, dummy_tail);
        last->next = new_node;
        dummy_tail->prev = new_node;
        size++; // 不要忘记size++
    }

    void addAtIndex(int index, int val) {
        if(index == size) {
            addAtTail(val);
            return;
        }
        Node* cur = at(index);
        if (cur == nullptr) {
            return;
        }
        Node* prev = cur->prev;
        Node* new_node = new Node(val, prev, cur);
        prev->next = new_node;
        cur->prev = new_node;
        size++; // 不要忘记size++
    }

    void deleteAtIndex(int index) {
        Node* cur = at(index);
        if (cur == nullptr) return;
        Node * prev = cur->prev, * next = cur->next;
        prev->next = next;
        next->prev = prev;
        delete cur;
        size--;
    }
};
```

## B4324 【模板】双向链表

### 题目描述

给出 $N$ 个结点，编号依次为 $1 \dots N$，初始按编号从小到大排列成一条双向链表。 

接下来有 $M$ 条指令，请按要求对链表进行修改。所有操作均保证合法。  

| 指令 | 含义 |
|:------:|:------:|
| $1\ x\ y$ | 将结点 $x$ 插入到 $y$ 的左侧（若 $x = y$ 则忽略本条指令）。 |
| $2\ x\ y$ | 将结点 $x$ 插入到 $y$ 的右侧（若 $x = y$ 则忽略本条指令）。 |
| $3\ x$   | 删除结点 $x$；若 $x$ 已被删除则忽略本条指令。 |

操作结束后，请按从左到右的顺序输出当前链表中所有结点的编号。

### 输入格式

第一行输入两个正整数 $N,M$，表示链表初始的结点数和操作指令数。

接下来 $M$ 行，每行一条指令，如题意所述。

### 输出格式

输出一行，即：操作结束后，按从左到右的顺序输出当前链表中所有结点的编号。如果链表不存在结点，输出 `Empty!`。

### 输入输出样例 #1

#### 输入 #1

```
10 7
1 2 3
2 4 5
3 2
1 9 4
2 7 8
3 4
3 10
```

#### 输出 #1

```
1 3 5 9 6 8 7
```

### 说明/提示

#### 样例解释

- 初始时，链表为：$1\ 2\ 3\ 4\ 5\ 6\ 7\ 8\ 9\ 10$；
- 第一次操作，将 $2$ 插入到 $3$ 左侧。由于初始时已经符合 $2$ 在 $3$ 左侧，所以链表还是：$1\ 2\ 3\ 4\ 5\ 6\ 7\ 8\ 9\ 10$；
- 第二次操作，将 $4$ 插入到 $5$ 的右侧，链表为：$1\ 2\ 3\ 5\ 4\ 6\ 7\ 8\ 9\ 10$；
- 第三次操作，删除结点 $2$，链表为：$1\ 3\ 5\ 4\ 6\ 7\ 8\ 9\ 10$；
- 第四次操作，将 $9$ 插入到 $4$ 的左侧，链表为：$1\ 3\ 5\ 9\ 4\ 6\ 7\ 8\ 10$；
- 第五次操作，将 $7$ 插入到 $8$ 的右侧，链表为：$1\ 3\ 5\ 9\ 4\ 6\ 8\ 7\ 10$；
- 第六次操作，删除结点 $4$，链表为：$1\ 3\ 5\ 9\ 6\ 8\ 7\ 10$；
- 第七次操作，删除结点 $10$，链表为：$1\ 3\ 5\ 9\ 6\ 8\ 7$；

#### 数据范围

- 对于 $30\%$ 的数据，$1\leq N,M\leq 10$；
- 对于 $60\%$ 的数据，$1\leq N,M\leq 3000$；
- 对于所有数据，$1\leq N,M\leq 5\times 10^5$；

### 答案
```C++
#include <bits/stdc++.h>
using namespace std;
struct List {
  struct Node {
    int val;
    Node *next, *prev;
  };
  int n;
  vector<Node *> nodes; // 链表配合其他数据结构进行操作
  vector<int> in_list;
  List(int n) : n(n) {
    nodes.resize(n + 2);
    in_list.resize(n + 2, true);
    for (int i = 0; i <= n + 1; i++) {
      nodes[i] = new Node(i, nullptr, nullptr);
    }
    for (int i = 0; i <= n + 1; i++) {
      if (i + 1 <= n + 1) {
        nodes[i]->next = nodes[i + 1];
      }
      if (i - 1 >= 0) {
        nodes[i]->prev = nodes[i - 1];
      }
    }
  }
  void insert(Node *cur, Node *new_node) {
    Node *next = cur->next;
    cur->next = new_node;
    next->prev = new_node;
    new_node->next = next;
    new_node->prev = cur;
  }
  void insert_before(int x, int y) {
    // node = erase(x);
    // insert(y->prev, node)
    if (x == y) return;
    Node* node = remove(x);
    insert(nodes[y]->prev, node);
  }
  void insert_after(int x, int y) {
    // node = erase(x);
    // insert(y->prev, node)
    if (x == y) return;
    Node* node = remove(x);
    insert(nodes[y], node);
  }
  Node *remove(int x) {
    if (!in_list[x]) return nullptr;
    Node *cur = nodes[x];
    Node *prev = cur->prev, *next = cur->next;
    prev->next = next;
    next->prev = prev;
    return cur;
  }
  void erase(int x) {

    remove(x);
    in_list[x] = false;
  }
  void output() {
    if (nodes[0]->next == nodes[n + 1]) {
      cout << "Empty!" << endl;
    }
    for (Node *cur = nodes[0]->next; cur != nodes[n + 1]; cur = cur->next) {
      cout << cur->val << ' ';
    }
    cout << endl;
  }
};
int main() {
  cin.tie(0)->sync_with_stdio(0);
  int n, m;
  cin >> n >> m;
  List list(n);
  while(m--) {
    int op, x, y;
    cin >> op >> x;
    if (op == 1) {
      cin >> y;
      list.insert_before(x, y);
    } else if (op == 2) {
      cin >> y;
      list.insert_after(x, y);
    } else {
      list.erase(x);
    }
  }
  list.output();
}
```

# 两两交换链表中的节点-LeetCode24
## 题目描述
给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

## 答案
![[Pasted image 20251006130508.png]]
```C++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummy = new ListNode(0,head);
        auto cur = dummy;
        while(cur->next && cur->next->next) {
            auto n1 = cur->next;
            auto n2 = cur->next->next;
            auto n3 = cur->next->next->next;
            cur->next = n2;
            n1->next = n3;
            n2->next = n1;
            cur = n1;
        }
        return dummy->next;
    }
};
```

# 旋转链表-LeetCode61

## 题目描述
给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。

## 答案
![[Pasted image 20251006230119.png]]

```C++
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if (head == nullptr) return nullptr;
        auto dummy = new ListNode(0, head);
        // 1. 优化k，k = k % len，找到tail
        auto T = dummy;
        int len = 0;
        for(; T->next; T = T->next) len++;
        k %= len;
        if (k == 0) return head;
        // 2. 找到倒数第k+1个节点
        auto K = dummy;
        int step = len - k;
        while(step--) K = K->next;
        // 3. 记录关键节点，改变
        auto F = dummy->next, N = K->next;
        dummy->next = N;
        T->next = F;
        K->next = nullptr;
        return dummy->next;
    }
};
```

# 删除排序链表中的重复元素-LeetCode83
## 题目描述
给定一个已排序的链表的头 `head` ， _删除所有重复的元素，使每个元素只出现一次_ 。返回 _已排序的链表_ 。
## 答案
```C++
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        for(auto cur = head; cur;) {
            if (cur->next && cur->next->val == cur->val) { // 记得确保cur->next存在
                cur->next = cur->next->next;
            } else {
                cur = cur->next;
            }
        }
        return head;
    }
};
```

# 删除排序链表中的重复元素2-LeetCode82
## 题目描述
给定一个已排序的链表的头 `head` ， _删除原始链表中所有重复数字的节点，只留下不同的数字_ 。返回 _已排序的链表_ 。
## 答案
![[Pasted image 20251006232115.png]]

```C++
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        auto dummy = new ListNode(0, head);
        for (auto cur = dummy; cur->next; ) {
            auto F = cur->next;
            auto L = F->next;
            while(L && L->val == F->val) L = L->next;
            if (F->next == L) cur = cur->next;
            else cur->next = L;
        }
        return dummy->next;
    }
};
```

# 分隔链表-LeetCode86
## 题目描述
给你一个链表的头节点 `head` 和一个特定值 `x` ，请你对链表进行分隔，使得所有 **小于** `x` 的节点都出现在 **大于或等于** `x` 的节点之前。

你应当 **保留** 两个分区中每个节点的初始相对位置。
## 答案
![[Pasted image 20251007123928.png]]
- 双指针，用D2一条链记录大于x的值，维护T1和T2
```C++
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode* d1 = new ListNode(0,0);
        ListNode* d2 = new ListNode(0,0);
        auto t1 = d1, t2 = d2;
        for(auto cur = head; cur; cur = cur->next) {
            if (cur->val < x) {
                t1->next = cur;
                t1 = t1->next;
            } else {
                t2->next = cur;
                t2 = t2->next;
            }
        }
        t1->next = d2->next;
        t2->next = nullptr;
        return d1->next;
    }
};
```

# 环形链表-LeetCode141
## 题目描述
给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。

_如果链表中存在环_ ，则返回 `true` 。 否则，返回 `false` 。
## 答案
![[Pasted image 20251007125443.png]]
- 技巧：快慢指针

```C++
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* dummy = new ListNode(0, head);
        auto p1 = dummy, p2 = dummy;
        do {
            if (p2->next == nullptr || p2->next->next == nullptr) {
                return false; // p2一定在p1前面，所以可以不判断p1->next == nullptr
            }
            p1 = p1->next;
            p2 = p2->next->next;
        } while (p1 != p2);
        return true;
    }
};
```

# 反转链表2-LeetCode92
## 题目描述
给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。
## 答案
![[Pasted image 20251007130823.png]]
```C++
class Solution {
    void reverseAfterK(ListNode *cur, int k) { // cur之后k个节点翻转
        auto T = cur->next;
        while(--k) { // 重复k-1次
            auto F = cur->next, N = T->next, NN = N->next;
            cur->next = N;
            N->next = F;
            T->next = NN;
        }
    }
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        ListNode* dummy = new ListNode(0, head);
        auto cur = dummy;
        for (int i = 1; i < left; i++) cur = cur->next;
        reverseAfterK(cur, right - left + 1);
        return dummy->next;
    }
};
```


# K个一组翻转链表-LeetCode25
## 题目描述
给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。

`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。
## 答案
- 尽可能分步骤编写，思路更清晰
```C++
class Solution {
    void reverseAfterK(ListNode *cur, int k) { // cur之后k个节点翻转
        auto T = cur->next;
        while(--k) { // 重复k-1次
            auto F = cur->next, N = T->next, NN = N->next;
            cur->next = N;
            N->next = F;
            T->next = NN;
        }
    }
    bool hasK(ListNode *cur, int k) {
        while(k--) {
            cur = cur->next;
            if (cur == nullptr) return false;
        }
        return true;
    }
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        // 0.当后续还存在k个节点
        // 1.翻转后续的k个节点
        // 2.改变当前结点（翻转后的最后一个结点，即翻转前第一个结点）
        auto dummy = new ListNode(0,head);
        auto cur = dummy;
        while(hasK(cur,k)) {
            auto F = cur->next;
            reverseAfterK(cur, k);
            cur = F;
        }
        return dummy->next;
    }
};
```

# LRU缓存-LeetCode146
## 题目描述
请你设计并实现一个满足  [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。
## 答案
```C++
class LRUCache {
    struct Node {
        int key, val;
        Node *prev, *next;
    };
    Node *head, *tail;
    int sz, cap;
    vector<Node*> nodes; // key<=10000,用数组下标来来表示key

    void removeNode(Node* cur) {
        Node *prev = cur->prev, *next = cur->next;
        prev->next = next;
        next->prev = prev;
    }
    void insert_first(Node* cur) {
        Node* first = head->next;
        cur->next = first;
        cur->prev = head;
        head->next = cur;
        first->prev = cur;
    }

public:
    LRUCache(int capacity) {
        // 0. head tail
        head = new Node(0,0,0,0);
        tail = new Node(0,0,head,0);
        head->next = tail;
        // 1. resize nodes
        nodes.resize(10001);
        // 2. 初始化sz，cap
        sz = 0;
        cap = capacity;
    }
    
    int get(int key) {
        // 0. key exist? -1
        if (!nodes[key]) return -1;
        // 1. remove node
        removeNode(nodes[key]);
        // 2. insert first
        insert_first(nodes[key]);
        // 3. return value
        return nodes[key]->val;
    }
    
    void put(int key, int value) {
        // 0. key exist?
        if (!nodes[key]) {
            // 1. new node()
            Node* new_node = new Node(key, value, 0 , 0);
            nodes[key] = new_node;
            sz++;
            // 2. insert first

            insert_first(new_node);
            // 3. judge capacity
            if (sz > cap) {
                // 4. remove tail
                sz--;
                nodes[tail->prev->key] = nullptr;
                removeNode(tail->prev);
            }
            return;
        }
        // 1. remove node
        Node *node = nodes[key];
        removeNode(node);
        // 2. insert first
        insert_first(node);
        // 3. update val
        node->val = value;
    }
};
```
