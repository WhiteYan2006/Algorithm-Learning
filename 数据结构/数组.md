---
date: 2025-09-14
tags:
  - 编程
  - Cpp
  - 数据结构
---
# C++ 容器相关知识概述

## 模版 & 初始化
当我们定义 `vector<int> vec;` 时，`<int>` 是模板参数。模板的作用是一次编写，到处复用，它是占位符，类似于函数的参数，由编译器帮你生成重复的代码。

```cpp
int arr[10];
map<int, double> mp;
sort(a.begin(), a.end(), greater<int>());
priority_queue<int, vector<int>, greater<int>> pq;
```

### 构造函数
```cpp
// vector(size_t n, T init = T());
vector<int> arr(10);
vector<int> arr(10, 123);

// vector(vector<T> &other);
vector<int> a(arr);
vector<int> a = arr;

// vector(initializer_list<T> init);
vector<int> b{1, 2, 3};
vector<int> b = {1, 2, 3};
```

## 下标访问
```cpp
vector<int> a = {1, 5, 9};
a[0];
a[1];
a[2];
a.at(-1); // 越界访问，会抛出异常
a.at(3);  // 越界访问，会抛出异常
```

## 大小 & 容量
数组是一段内存连续的空间，通过 `data[index]` 可访问，等价于 `data + index`。vector 能不断增加元素且保持内存连续，是通过动态扩容实现的。当 `push_back` 100 次时，复制次数遵循类似 `2^k - 1 >= n` 的规律（如代码块所示）。
![[Pasted image 20250914095841.png]]

### 容量相关方法
```cpp
int capacity(); // 返回当前容量
void reserve(int new_capacity); // 预留这么大的空间
void push_back(T elem); // 如果容量不足，申请更多的空间

void resize(int n, T init = T()); // 需要这么大的大小，并用 init 来填充多的部分
void pop_back(); // size --;
void clear(); // size = 0
```

## 常量 const
- **引用传参**：避免大数据产生复制。
- **const 引用**：让临时变量也可以被引用，示例代码：
  ```cpp
  void function(const T& a) {}
  ```
- **const 成员函数**：让 const 的对象也可以调用，示例代码：
  ```cpp
  class MyVector {
      size_t size() const {}
  };
  ```
- **const 引用返回值**：避免返回值被错误的修改，示例代码：
  ```cpp
  class MyVector {
      T& operator[](int index) {}
      const T& operator[](int index) const {}
  };
  ```

## 迭代器
迭代器可对容器数据进行封装，屏蔽容器的底层实现，支持泛型算法。
```cpp
for (vector<int>::iterator iter = vec.begin(); iter != vec.end(); iter ++) {
    cout << *iter << endl;
}
for (map<int, int>::iterator iter = mp.begin(); iter != mp.end(); iter ++) {
    cout << iter->first << ' ' << iter->second << endl;
}
sort(vec.begin(), vec.end());
vector<int>::iterator iter = max_element(vec.begin(), vec.end());
cout << *iter << endl;
vector<int>::iterator iter = lower_bound(vec.begin(), vec.end(), 123);
cout << iter - vec.begin() << endl;
```

## 插入、删除
```cpp
void insert(const iterator &pos, const T& x);
void erase(const iterator &pos);
void erase(const iterator &start, const iterator &end);
```



# 数组-创建自己的数组

在 C++ 中，标准库提供了 `vector` 这样强大的动态数组容器，但了解如何自己实现一个类似的动态数组，能帮助我们更深入理解底层原理。下面将从内存管理、初始化方式（含简化初始化）、元素访问等方面，介绍如何创建自己的数组类 `MyVec`。

## 内存管理：new 与 delete
在手动实现动态数组时，需要手动管理内存的分配与释放，这就用到了 `new` 和 `delete` 操作符。
### new 操作符
`new` 用于在堆上分配内存。例如在 `MyVec` 的构造函数中，当需要为数组分配指定大小的内存时，使用 `new T[n]`，它会在堆上开辟能存储 `n` 个 `T` 类型元素的连续内存空间，并返回指向该内存起始地址的指针。这样我们就可以通过指针来操作这块内存中的元素了。
### delete 操作符
由于 `new` 分配的内存不会自动释放，若不手动释放会造成内存泄漏。`delete` 操作符用于释放由 `new` 分配的内存。在 `MyVec` 的析构函数 `~MyVec()` 中，使用 `delete[] _data`，`delete[]` 是专门用于释放由 `new[]` 分配的数组内存的，这样可以确保在 `MyVec` 对象生命周期结束时，其内部动态分配的内存被正确释放，避免内存泄漏。

## 初始化方式
### 默认初始化
```cpp
MyVec() { // 默认初始化，不含传入值
    _data = nullptr; // 避免_data和_size变成未初始化的奇怪值
    _size = 0;
}
```
当不传入任何参数创建 `MyVec` 对象时，会调用默认构造函数。此时将指向数据的指针 `_data` 置为 `nullptr`，表示当前没有分配内存，数组大小 `_size` 置为 `0`。

### 简化的默认初始化（成员初始化列表）
```cpp
MyVec() : _data(nullptr), _size(0) {} // 简化形式的默认初始化函数
```
成员初始化列表是一种更简洁的初始化方式。它在构造函数的冒号后，直接对类的成员变量进行初始化，比在构造函数体内赋值更加高效，尤其是对于一些复杂类型的成员变量。这里直接将 `_data` 初始化为 `nullptr`，`_size` 初始化为 `0`。

### 指定大小和初始值初始化
```cpp
MyVec(int n, T init = T()) { // 初始化函数
    _data = new T[n]; // 申请对应大小的内存
    for (int i = 0; i < n; i++) {
        _data[i] = init; // 初始化赋值
    }
    _size = n; // 数组大小
}
```
这个构造函数允许我们创建指定大小 `n` 的数组，并且可以指定初始值 `init`（若不指定，使用 `T` 类型的默认构造值）。通过 `new T[n]` 分配内存后，遍历为每个元素赋予初始值 `init`，同时设置数组大小 `_size` 为 `n`。

### 简化的指定大小和初始值初始化（成员初始化列表）
```cpp
MyVec(int n, T init = T()) : _data(new T[n]), _size(n) { // 简化的初始化函数
    for (int i = 0; i < _size; i++) {
        _data[i] = init;
    }
}
```
利用成员初始化列表，在构造函数一开始就完成 `_data`（分配 `n` 个 `T` 类型元素的内存）和 `_size`（设为 `n`）的初始化，然后在构造函数体内只需完成每个元素的赋值操作，代码更加简洁高效。

### 拷贝初始化
```cpp
MyVec(MyVec<T> &other) { // 支持传入另外一个MyVec的初始化
    _data = new T[other.size()];
    for (int i = 0; i < other.size(); i++) {
        _data[i] = other[i];
    }
    _size = other.size();
}
```
拷贝构造函数用于根据已有的 `MyVec` 对象 `other` 来创建新的 `MyVec` 对象。首先为新对象分配与 `other` 大小相同的内存，然后逐个复制 `other` 中的元素到新分配的内存中，最后设置新对象的大小与 `other` 相同。

### 简化的拷贝初始化（成员初始化列表）
```cpp
MyVec(MyVec<T> &other) : _data(new T[other.size()]), _size(other.size()) { // 简化的支持传入另外一个MyVec的初始化
    for (int i = 0; i < other.size(); i++) {
        _data[i] = other[i];
    }
}
```
通过成员初始化列表，在构造函数初始化阶段就完成 `_data`（分配与 `other` 大小相同的内存）和 `_size`（设为 `other.size()`）的初始化，之后在构造函数体内进行元素的复制，让代码结构更清晰。

### 列表初始化（initializer_list）
```cpp
MyVec(initializer_list<T> init) { // 列表初始化
    // C++11提供的更方便的列表初始化initializer_list,但是不支持下标访问
    _data = new T[init.size()];
    _size = 0;
    for (T x: init) { // 使用范围循环来规避下标访问
        _data[_size++] = x;
    }
}
```
C++11 引入了 `initializer_list`，使得我们可以用初始化列表（如 `{1,2,3,4,5}`）来初始化 `MyVec`。在构造函数中，先根据初始化列表的大小分配内存，然后通过范围循环遍历初始化列表中的元素，依次存入动态分配的内存中，同时更新数组大小 `_size`。

### 简化的列表初始化（成员初始化列表）
```cpp
MyVec(initializer_list<T> init) : _data(new T[init.size()]), _size(0) { // 简化的列表初始化
    for (T x: init) { 
        _data[_size++] = x;
    }
}
```
借助成员初始化列表，在构造函数初始化时就完成 `_data`（分配与初始化列表大小相同的内存）和 `_size`（初始化为 `0`）的设置，之后在构造函数体内通过范围循环填充元素并更新 `_size`，代码更简洁。

## 元素访问：运算符重载
### `[]`运算符重载
```cpp
T &operator[](size_t index) { // 运算符重载来支持[]下标访问，加上引用支持修改
    return _data[index];
}
```
通过重载 `[]` 运算符，我们可以像访问普通数组一样访问 `MyVec` 中的元素。返回的是元素的引用，这意味着不仅可以读取元素值，还可以修改元素值，例如 `vec[0] = 10;` 这样的操作是合法的。

### at 方法（带越界检测）
```cpp
T &at(size_t index) { // at下标访问，支持越界检测
    if (index >= _size) {
        cout << format("index = {0}, _size = {1}",index,_size) << endl;
        throw out_of_range("MyVec下标访问越界");
    }
    return _data[index];
}
```
`at` 方法也用于访问数组元素，但它会进行越界检测。如果传入的索引 `index` 大于等于数组大小 `_size`，会输出错误信息并抛出 `out_of_range` 异常，相比 `[]` 运算符，更加安全。

## 完整代码示例
```cpp
#include <bits\stdc++.h>
using namespace std;

template<typename T>
class MyVec {
 private:
  T *_data; //内部成员变量前加下划线区分
  size_t _size;
 public:
  //在不自行规定初始化函数时C++会提供默认初始化函数，添加自定义初始化函数后则需要自行编写默认初始化函数
  MyVec() { //默认初始化，不含传入值
    _data = nullptr; //避免_data和n变成奇怪的值
    _size = 0;
  }

  //当初始化函数没有复杂逻辑只有简单赋值时可以简化
  // MyVec() : _data(nullptr), _size(0) {} //简化形式的默认初始化函数

  MyVec(int n, T init = T()) { //初始化函数
    _data = new T[n]; //申请对应大小的内存
    for (int i = 0; i < n; i++) {
      _data[i] = init; // 初始化赋值
    }
    _size = n; // 数组大小
  }

  // MyVec(int n, T init = T()) : _data(new T[n]), _size(n) { // 简化的初始化函数
  //   for (int i = 0; i < _size; i++) {
  //     _data[i] = init;
  //   }
  //   _size = n;
  // }



  MyVec(MyVec<T> &other) { //支持传入另外一个MyVec的初始化
    _data = new T[other.size()];
    for (int i = 0; i < other.size(); i++) {
      _data[i] = other[i];
    }
    _size = other.size();
  }

  // MyVec(MyVec<T> &other) : _data(new T[other.size()]), _size(other.size()) { //简化的支持传入另外一个MyVec的初始化
  //   for (int i = 0; i < other.size(); i++) {
  //     _data[i] = other[i];
  //   }
  // }


  MyVec(initializer_list<T> init) { // 列表初始化
    // C++11提供的更方便的列表初始化initializer_list,但是不支持下标访问
    _data = new T[init.size()];
    _size = 0;
    for (T x: init) { //使用范围循环来规避下标访问
      _data[_size++] = x;
    }
  }

  // MyVec(initializer_list<T> &init) : _data(new T[init.size()]), _size(0) { // 简化的列表初始化
  //   for (T x: init) { 
  //     _data[_size++] = x;
  //   }
  
  // 申请内存一定要记得释放
  ~MyVec() { // 析构函数释放内存，防止内存泄漏
    delete[] _data;
  }
  T &operator[](size_t index) { //运算符重载来支持[]下标访问，加上引用支持修改
    return _data[index];
  }

  T &at(size_t index) { //at下标访问，支持越界检测
    if (index >= _size) {
      cout << format("index = {0}, _size = {1}",index,_size) << endl;
      throw out_of_range("MyVec下标访问越界");
    }
    return _data[index];
  }

  size_t size() {
    return _size;
  }
};


int main() {
  MyVec<int> vec =  {1,2,3,4,5};
  for (int i = 0; i < 123; i ++) {
    cout << vec.at(i) << " ";
  }
  
}
```


---


# 动态扩容
- 基本原理：重新开一块内存空间，把原来的数据复制过去，再添上新元素值
- 当需要扩容时C++默认会额外申请一个原来数组内存空间两倍大的空间
- 如果空间又满了就再次额外申请双倍的内存空间

### push_back 100 次，产生了多少复制？

```
1  0 1
2  1 2  (1)
3  2 3  (2)
4  4 5  (4)
5  8 9  (8)
6  16 17 (16)
7  32 33 (32)
8  64 65 (64)
9  128  (127)<-此处为1+2+4+...+64的值，代表一共复制了多少次数据  2^k - 1 >= n
```

- 对于单次`push_back`的复杂度是O(n)，但是对于多次push_back平均下来的复杂度是O(1)，因为总复制次数$2^{k}- 1$和`push_back`次数n是同数量级的

## 代码实现
```Cpp
#include <bits\stdc++.h>
using namespace std;

template<typename T>
class MyVec {
 private:
  T *_data; //内部成员变量前加下划线区分
  size_t _size;
  size_t _capacity;
 public:
  MyVec() : _data(nullptr), _size(0), _capacity(0) {} //简化形式的默认初始化函数


  MyVec(size_t n, T init = T()) : _data(new T[n]), _size(n), _capacity(n) { // 简化的初始化函数
    for (size_t i = 0; i < _size; i++) {
      _data[i] = init;
    }
    _size = n;
  }
  MyVec(MyVec<T> &other) : _data(new T[other.size()]), _size(other.size()), _capacity(other.size()) { //简化的支持传入另外一个MyVec的初始化
    for (size_t i = 0; i < other.size(); i++) {
      _data[i] = other[i];
    }
  }
  MyVec(initializer_list<T> init) : _data(new T[init.size()]), _size(0), _capacity(init.size()) { // 简化的列表初始化
    for (T x: init) { 
      _data[_size++] = x;
    } 
  }
  // 申请内存一定要记得释放
  ~MyVec() { // 析构函数释放内存，防止内存泄漏
    delete[] _data;
  }
  T &operator[](size_t index) { //运算符重载来支持[]下标访问，加上引用支持修改
    return _data[index];
  }
  T &at(size_t index) { //at下标访问，支持越界检测
    if (index >= _size) {
      cout << format("index = {0}, _size = {1}",index,_size) << endl;
      throw out_of_range("MyVec下标访问越界");
    }
    return _data[index];
  }

  size_t size() {
    return _size;
  }

  size_t capacity() { //返回容量
    return _capacity;
  }
  void reserve(size_t new_capacity) { //扩容函数
    if (new_capacity > _capacity) {
      _capacity = new_capacity;
      T *new_data = new T[_capacity]; //申请一段新内存
      for (size_t i = 0; i < _size; i++) new_data[i] = _data[i]; //把老内存中的内容挨个复制
      delete[] _data; //回收原来的data的内存
      _data = new_data;
    }
  }

  void push_back(T elem) {
    if (_size == _capacity) {
      reserve(_capacity == 0 ? 1 : _capacity * 2); //如果原容量为0则扩容到1，不是0则翻倍
    }
    _data[_size++] = elem;
  }

  void resize(size_t new_size, T init = T()) {
    if (new_size > _capacity) reserve(new_size);
    for (size_t i = _size; i < new_size; i++) {
      _data[i] = init;
    }
    _size = new_size;
  }

  void pop_back() { //pop_back的实现原理就是让_size-1，不需要去清空原来内存上的数据
    if (_size == 0) {
      throw out_of_range("cannot pop_back empty vector");
    }
    _size--;
  }

  void clear() { // clear的原理就是把_size变成0
    _size = 0;
  }
};
```


### 1. 获取容量：`capacity` 方法
```cpp
size_t capacity() {
    return _capacity;
}
```
该方法用于返回当前 `MyVec` 对象的容量，即已分配内存能容纳的最大元素数量。

### 2. 扩容函数：`reserve` 方法
```cpp
void reserve(size_t new_capacity) {
    if (new_capacity > _capacity) {
        _capacity = new_capacity;
        T *new_data = new T[_capacity]; // 申请一段新内存
        for (size_t i = 0; i < _size; i++) new_data[i] = _data[i]; // 把老内存中的内容挨个复制
        delete[] _data; // 回收原来的data的内存
        _data = new_data;
    }
}
```
- 作用：当需要确保 `MyVec` 至少能容纳 `new_capacity` 个元素时，调用此方法。若 `new_capacity` 大于当前容量 `_capacity`，则进行扩容操作。
- 扩容逻辑：
  - 先申请一块大小为 `new_capacity` 的新内存，用指针 `new_data` 指向它。
  - 将原内存 `_data` 中的元素逐个复制到新内存 `new_data` 中。
  - 释放原内存 `_data`（避免内存泄漏）。
  - 将 `_data` 指向新内存 `new_data`，并更新 `_capacity` 为 `new_capacity`。

### 3. 尾部添加元素：`push_back` 方法
```cpp
void push_back(T elem) {
    if (_size == _capacity) {
        reserve(_capacity == 0 ? 1 : _capacity * 2); // 如果原容量为0则扩容到1，不是0则翻倍
    }
    _data[_size++] = elem;
}
```
- 作用：在 `MyVec` 的尾部添加一个元素 `elem`。
- 扩容触发：当当前元素个数 `_size` 等于容量 `_capacity` 时，说明内存已满，需要扩容。
  - 若当前容量 `_capacity` 为 `0`（初始状态或已被清空到容量为 `0`），则扩容到能容纳 `1` 个元素。
  - 若当前容量 `_capacity` 不为 `0`，则扩容为原来的 `2` 倍（这种**“成倍扩容”**策略能减少扩容的频率，降低时间开销）。
- 元素添加：扩容完成后，将新元素 `elem` 存入 `_data[_size]` 的位置，然后 `_size` 自增 `1`。

### 4. 调整大小：`resize` 方法
```cpp
void resize(size_t new_size, T init = T()) {
    if (new_size > _capacity) reserve(new_size);
    for (size_t i = _size; i < new_size; i++) {
        _data[i] = init;
    }
    _size = new_size;
}
```
- 作用：将 `MyVec` 的大小调整为 `new_size`。若 `new_size` 大于当前 `_size`，新增的元素用 `init` 初始化（若未指定 `init`，则用 `T` 类型的默认构造值）。
- 直接修改`_size`而不用处理原来内存中存的值

### 5. 尾部删除元素：`pop_back` 方法
```cpp
void pop_back() {
    if (_size == 0) {
        throw out_of_range("cannot pop_back empty vector");
    }
    _size--;
}
```
- 作用：删除 `MyVec` 尾部的一个元素。
- 实现逻辑：不需要对原来内存中的数据进行处理，直接将 `_size` 减 `1`即可实现

### 6. 清空容器：`clear` 方法
```cpp
void clear() {
    _size = 0;
}
```
- 作用：清空 `MyVec` 中的所有元素。
- 实现逻辑：只需将 `_size` 置为 `0`，表示容器中没有有效元素（内存不会被释放，只是有效范围被置空，后续可复用这部分内存）。


---


# 常量const
- 引用传参
	- 避免大数据产生复制
- const+引用
	- 让临时变量也能被引用
- const成员函数
	- 让const对象也可以调用
- const引用返回值
	- 避免返回值被错误修改

## 代码
```Cpp

```#include <bits\stdc++.h>
using namespace std;

template<typename T>
class MyVec {
 private:
  T *_data; //内部成员变量前加下划线区分
  size_t _size;
  size_t _capacity;
 public:
  MyVec() : _data(nullptr), _size(0), _capacity(0) {} //简化形式的默认初始化函数
  MyVec(size_t n, T init = T()) : _data(new T[n]), _size(n), _capacity(n) {
    for (size_t i = 0; i < _size; i++) {
      _data[i] = init;
    }
    _size = n;
  }
  MyVec(const MyVec<T> &other) : _data(new T[other.size()]), _size(other.size()), _capacity(other.size()) { // const+引用避免大数据复制和允许临时变量传入
    for (size_t i = 0; i < other.size(); i++) {
      _data[i] = other[i];
    }
  }
  MyVec(const initializer_list<T> &init) : _data(new T[init.size()]), _size(0), _capacity(init.size()) { // const+引用避免大数据复制和允许临时变量传入
    for (T x: init) { 
      _data[_size++] = x;
    } 
  }
  
  ~MyVec() {
    delete[] _data;
  }
  T &operator[](size_t index) { //运算符重载来支持[]下标访问，加上引用支持修改，（非const时调用）
    return _data[index]; // 返回可以被修改的引用
  }
  const T &operator[](size_t index) const { //单独为const编写下标访问，最前面的const代表返回的引用不可修改
    return _data[index]; // 返回不能被修改的引用
  }

  T &at(size_t index) { //at下标访问，支持越界检测
    if (index >= _size) {
      cout << format("index = {0}, _size = {1}",index,_size) << endl;
      throw out_of_range("MyVec下标访问越界");
    }
    return _data[index];
  }
  const T &at(size_t index) const { //和[]下标访问一样，写const和非const两个版本
    if (index >= _size) {
      cout << format("index = {0}, _size = {1}",index,_size) << endl;
      throw out_of_range("MyVec下标访问越界");
    }
    return _data[index];
  }

  size_t size() const { //在使用成员函数时，如果未加声明则默认其中的值可以修改，而const对象不能调用可修改的函数，需在函数圆括号和大括号中间加上const才能被const对象调用
    // 如果函数中不改变任何值，则加上const声明，使得原本是const的MyVec能够调用函数
    return _size;
  }

  size_t capacity() const { //返回容量
    return _capacity;
  }
  void reserve(size_t new_capacity) { //扩容函数
    if (new_capacity > _capacity) {
      _capacity = new_capacity;
      T *new_data = new T[_capacity]; //申请一段新内存
      for (size_t i = 0; i < _size; i++) new_data[i] = _data[i]; //把老内存中的内容挨个复制
      delete[] _data; //回收原来的data的内存
      _data = new_data;
    }
  }

  void push_back(T elem) {
    if (_size == _capacity) {
      reserve(_capacity == 0 ? 1 : _capacity * 2); //如果原容量为0则扩容到1，不是0则翻倍
    }
    _data[_size++] = elem;
  }

  void resize(size_t new_size, T init = T()) {
    if (new_size > _capacity) reserve(new_size);
    for (size_t i = _size; i < new_size; i++) {
      _data[i] = init;
    }
    _size = new_size;
  }

  void pop_back() { //pop_back的实现原理就是让_size-1，不需要去清空原来内存上的数据
    if (_size == 0) {
      throw out_of_range("cannot pop_back empty vector");
    }
    _size--;
  }

  void clear() { // clear的原理就是把_size变成0
    _size = 0;
  }
};



void f(const MyVec<int> &b) { //加上const使得临时变量（左值）如{1,2,3}能够传入函数
  //引用传参避免大数据产生复制
  cout << b.size() << endl;
}
int main() {
  MyVec<int> a(100);
  f(a);
  f({1,2,3});
}
```


----



# 迭代器，让容器支持算法

- 迭代器不等于指针，是对容器数据的封装
- 屏蔽容器的底层实现
- 支持泛型的算法
## 一、迭代器（Iterator）的概念与作用

迭代器是容器（如数组、向量等）的"通用指针"，它封装了对容器元素的访问方式，提供了统一的接口来遍历容器中的元素，而无需暴露容器的底层实现细节。

在`MyVec`类中，迭代器的核心作用是：
- 提供一种统一的方式遍历自定义容器`MyVec`中的元素
- 支持与STL算法（如`sort`）配合使用
- 屏蔽底层数组的实现细节，即使未来修改存储结构，遍历方式仍可保持一致

## 二、迭代器类的实现细节

### 2.1 迭代器的核心成员

```cpp
class iterator {
private:
    T* ptr;  // 底层指针，指向容器中的元素
public:
    using value_type = T;  // 声明数据类型，供STL算法使用
    // ... 成员函数
};
```

- `ptr`：实际指向容器中元素的指针，是迭代器的核心
- `value_type`：类型别名，声明迭代器所指向元素的类型，这是与STL算法兼容的必要条件

### 2.2 迭代器的构造函数

```cpp
iterator() {}  // 默认构造函数
iterator(T* ptr): ptr(ptr) {}  // 接受指针的构造函数
```

- 提供了默认构造和接受指针的构造方式，方便创建迭代器对象

### 2.3 解引用操作符

```cpp
T &operator*() const {  // 解引用操作
    return *ptr;
}
T *operator->() const {  // 成员访问操作
    return ptr;
}
```

- `operator*()`：返回指针指向元素的引用，允许通过迭代器修改元素值
- `operator->()`：返回指针本身，用于访问元素的成员（如`iter->member`）
#### `->`符号
```C++
  struct MyStruct
  {
      int x;
      void display() { cout << "Value: " << x << endl; }
  };

  MyStruct myObj;
  MyStruct* pMyObj = &myObj;

  // 使用`.`运算符访问对象的成员
  myObj.x = 10;
  myObj.display();

  // 使用`->`运算符通过指针访问对象的成员
  pMyObj->x = 20;
  pMyObj->display();
```
### 2.4 迭代器移动操作

#### 前置与后置递增

```cpp
// ++iter (前置递增)
iterator& operator++() {
    ptr++;
    return *this;  // 返回递增后的自身引用
}

// iter++ (后置递增)
iterator operator++(int) {
    iterator temp = *this;  // 保存当前状态
    ptr++;
    return temp;  // 返回递增前的副本
}
```

- 前置递增返回引用，效率更高，推荐使用（如`++iter`）
- 后置递增需要创建临时对象，效率略低

#### 前置与后置递减

```cpp
iterator& operator--() {  // --iter
    ptr--;
    return *this;
}

iterator operator--(int) {  // iter--
    iterator temp = *this;
    ptr--;
    return temp;
}
```

### 2.5 迭代器算术运算

```cpp
// 迭代器加上整数n，返回新迭代器
iterator operator+(int n) const {
    return iterator(ptr + n);
}

// 迭代器减去整数n，返回新迭代器
iterator operator-(int n) const {
    return iterator(ptr - n);
}

// 两个迭代器相减，返回元素个数差
int operator-(const iterator &other) const {
    return ptr - other.ptr;
}
```

### 2.6 迭代器比较操作

```cpp
// 比较迭代器位置
bool operator<(const iterator &other) const {
    return ptr < other.ptr;
}

// 判断迭代器是否指向同一位置
bool operator==(const iterator &other) const {
    return ptr == other.ptr;
}

// 判断迭代器是否指向不同位置
bool operator!=(const iterator& other) const {
    return ptr != other.ptr;
}
```

- 这些比较操作使得迭代器可以用于循环条件和范围判断

## 三、容器类中的迭代器接口

`MyVec`类提供了获取迭代器的接口，用于标识容器的起始和结束位置：

```cpp
iterator begin() {
    return iterator(_data);  // 返回指向第一个元素的迭代器
}

iterator end() {
    return iterator(_data + _size);  // 返回指向最后一个元素后一位的迭代器
}
```

- `begin()`：返回指向容器第一个元素的迭代器
- `end()`：返回指向容器最后一个元素**之后**位置的迭代器（形成左闭右开区间`[begin, end)`）

## 四、迭代器的使用场景

### 4.1 遍历容器元素

```cpp
MyVec<int> vec{1,2,3,4};
for (MyVec<int>::iterator iter = vec.begin(); iter != vec.end(); ++iter) {
    cout << *iter << endl;  // 通过解引用访问元素
}
```

- 遍历范围是`[begin(), end())`，确保所有元素都被访问且不越界
- 推荐使用前置递增`++iter`，效率更高

### 4.2 与STL算法配合使用

```cpp
sort(vec.begin(), vec.end());  // 使用STL的sort算法排序
```

- 由于`MyVec`的迭代器实现了必要的操作符重载，使得它可以与STL算法兼容
- 这展示了迭代器的重要价值：提供统一接口，让不同容器可以使用相同的算法

## 代码
```C++
#include <bits\stdc++.h>
using namespace std;

template<typename T>
class MyVec {
 private:
  T *_data; //内部成员变量前加下划线区分
  size_t _size;
  size_t _capacity;
 public:
  MyVec() : _data(nullptr), _size(0), _capacity(0) {} //简化形式的默认初始化函数


  MyVec(size_t n, T init = T()) : _data(new T[n]), _size(n), _capacity(n) { // 简化的初始化函数
    for (size_t i = 0; i < _size; i++) {
      _data[i] = init;
    }
    _size = n;
  }


  MyVec(const MyVec<T> &other) : _data(new T[other.size()]), _size(other.size()), _capacity(other.size()) { //简化的支持传入另外一个MyVec的初始化
    for (size_t i = 0; i < other.size(); i++) {
      _data[i] = other[i];
    }
  }


  MyVec(const initializer_list<T> &init) : _data(new T[init.size()]), _size(0), _capacity(init.size()) { // 简化的列表初始化
    for (T x: init) { 
      _data[_size++] = x;
    } 
  }
  
  // 申请内存一定要记得释放
  ~MyVec() { // 析构函数释放内存，防止内存泄漏
    delete[] _data;
  }
  T &operator[](size_t index) { //运算符重载来支持[]下标访问，加上引用支持修改，（非const时调用）
    return _data[index]; // 返回可以被修改的引用
  }
  const T &operator[](size_t index) const { //单独为const编写下标访问，最前面的const代表返回的引用不可修改
    return _data[index]; // 返回不能被修改的引用
  }

  T &at(size_t index) { //at下标访问，支持越界检测
    if (index >= _size) {
      cout << format("index = {0}, _size = {1}",index,_size) << endl;
      throw out_of_range("MyVec下标访问越界");
    }
    return _data[index];
  }
  const T &at(size_t index) const { //和[]下标访问一样，写const和非const两个版本
    if (index >= _size) {
      cout << format("index = {0}, _size = {1}",index,_size) << endl;
      throw out_of_range("MyVec下标访问越界");
    }
    return _data[index];
  }

  size_t size() const { //在使用成员函数时，如果未加声明则默认其中的值可以修改，而const对象不能调用可修改的函数，需在函数圆括号和大括号中间加上const才能被const对象调用
    // 如果函数中不改变任何值，则加上const声明，使得原本是const的MyVec能够调用函数
    return _size;
  }

  size_t capacity() const { //返回容量
    return _capacity;
  }
  void reserve(size_t new_capacity) { //扩容函数
    if (new_capacity > _capacity) {
      _capacity = new_capacity;
      T *new_data = new T[_capacity]; //申请一段新内存
      for (size_t i = 0; i < _size; i++) new_data[i] = _data[i]; //把老内存中的内容挨个复制
      delete[] _data; //回收原来的data的内存
      _data = new_data;
    }
  }

  void push_back(T elem) {
    if (_size == _capacity) {
      reserve(_capacity == 0 ? 1 : _capacity * 2); //如果原容量为0则扩容到1，不是0则翻倍
    }
    _data[_size++] = elem;
  }

  void resize(size_t new_size, T init = T()) {
    if (new_size > _capacity) reserve(new_size);
    for (size_t i = _size; i < new_size; i++) {
      _data[i] = init;
    }
    _size = new_size;
  }

  void pop_back() { //pop_back的实现原理就是让_size-1，不需要去清空原来内存上的数据
    if (_size == 0) {
      throw out_of_range("cannot pop_back empty vector");
    }
    _size--;
  }

  void clear() { // clear的原理就是把_size变成0
    _size = 0;
  }

  class iterator {
   private:
    T* ptr;
   public:
   using value_type = T; // 要使用STL算法，需要用value_type声明数据类型
    iterator() {}
    iterator(T* ptr): ptr(ptr) {}
    T &operator*() const { //加上&,这样解引用迭代器时会返回元素的引用，允许修改元素值
      return *ptr;
    }
    T *operator->() const { //指向地址，->符号代表“通过指针访问对象成员”
      return ptr;
    }
    // ++iter,括号里不填
    iterator& operator++() {
      ptr++;
      return *this; //返回自身
    }
    //iter++,括号里填int
    iterator operator++(int) {
      iterator temp = *this;
      ptr++;
      return *this;
    }
    iterator& operator--() {
      ptr--;
      return *this;
    }
    iterator operator--(int) {
      iterator temp = *this;
      ptr--;
      return *this;
    }

    iterator operator+(int n) const {
      return iterator(ptr + n);
    }
    iterator operator-(int n) const {
      return iterator(ptr - n);
    }
    int operator-(const iterator &other) const {
      return ptr - other.ptr;
    }
    bool operator<(const iterator &other) const {
      return ptr < other.ptr;
    }
    bool operator==(const iterator &other) const {
      return ptr == other.ptr;
    }
    bool operator!=(const iterator& other) const { // 重载!=使得迭代器支持不等号比较
      return ptr != other.ptr;
    }
  };
  iterator begin() {
    return iterator(_data);
  }
  iterator end() {
    return iterator(_data + _size);
  }
};


int main() {
  MyVec<int> vec{1,2,3,4};
  for (MyVec<int>::iterator iter = vec.begin(); iter != vec.end(); ++iter) { //对于非基础类型，写++最好写在前面
    cout << *iter << endl;
  }
  sort(vec.begin(), vec.end());
}
```


## 插入，删除

插入和删除在非特殊情况下复杂度为$O(n)$
```C++
void insert(const iterator &pos, T x) { // 传入数据时不引用，防止insert传入数组内数据时出bug
    size_t index = pos - begin();
    if (_size == _capacity) reserve(_capacity == 0 ? 1 : _capacity * 2);
    for (size_t i = _size; i > index; i--) _data[i] = _data[i - 1];
    _data[index] = x;
    _size++;
  }
void erase(const iterator &pos) {
    for (size_t i = pos - begin(); i < _size - 1; i++) {
      _data[i] = _data[i + 1];
    }
    _size--;
  }
  void erase(const iterator &start, const iterator &end) {
    int diff = end - start;
    for (size_t i = start - begin(); i < _size - diff; i++) {
      _data[i] = _data[i + diff];
    }
    _size -= diff;
  }
```


# 其他内容补全

## 一、赋值运算符重载（`operator=`）

### 1.1 功能与实现原理
赋值运算符用于将一个容器的内容完整复制到另一个容器，实现容器间的赋值操作。

```cpp
MyVec<T>& operator=(const MyVec<T> &other) {
    if (this != &other) {  // 检查自赋值，避免不必要的操作和错误
        delete[] _data;    // 释放当前容器的内存
        _data = new T[other.size()];  // 分配与源容器相同大小的内存
        _size = other.size();         // 复制大小
        _capacity = other.capacity(); // 复制容量
        // 逐个复制元素
        for (size_t i = 0; i < other.size(); i++) {
            _data[i] = other[i];
        }
    }
    return *this;  // 返回自身引用，支持链式赋值
}
```

### 1.2 关键要点
- **自赋值检查**：`if (this != &other)` 是必要的，防止自身赋值时释放内存后导致的数据丢失
- **内存管理**：先释放当前内存，再分配新内存，避免内存泄漏
- **返回值**：返回自身引用（`*this`），支持链式赋值（如 `a = b = c`）
- **深拷贝**：对元素进行逐个复制，确保两个容器拥有独立的内存空间

## 二、首尾元素访问接口

### 2.1 `front()` 函数
用于获取容器的第一个元素：
```cpp
T& front() {
    return _data[0];
}
const T& front() const {
    return _data[0];
}
```

### 2.2 `back()` 函数
用于获取容器的最后一个元素：
```cpp
T& back() {
    return _data[_size - 1];
}
const T& back() const {
    return _data[_size - 1];
}
```

### 2.3 设计特点
- **const 重载**：提供普通版本和 const 版本，分别供非 const 对象和 const 对象使用
- **返回引用**：返回元素的引用，允许直接修改元素值（普通版本）
- **效率**：时间复杂度为 O(1)，直接通过索引访问，无需遍历

> 注意：使用这两个函数前应确保容器非空，否则会访问越界

## 三、判空函数（`empty()`）

```cpp
bool empty() const {
    return _size == 0;
}
```

- 功能：判断容器是否为空（即元素数量是否为 0）
- 返回值：`true` 表示容器为空，`false` 表示容器非空
- 应用场景：在调用 `front()`、`back()`、`pop_back()` 等函数前进行检查，避免越界访问

## 四、原地构造插入（`emplace_back()`）

### 4.1 功能与实现
`emplace_back()` 用于在容器尾部插入一个新元素，与 `push_back()` 不同的是，它直接在容器内存中构造元素，而非先创建临时对象再复制。

```cpp
template<typename... Args>  // 可变参数模板，支持任意类型和数量的参数
void emplace_back(const Args&... args) {
    // 检查容量，不足则扩容
    if (_size == _capacity) {
        reserve(_capacity == 0 ? 1 : _capacity * 2);
    }
    // 直接在容器内存中构造元素
    _data[_size++] = T(args...);
}
```

### 4.2 关键技术：可变参数模板
- `template<typename... Args>`：声明可变参数模板，`Args` 为参数包
- `const Args&... args`：声明参数包的引用，用于接收传递的实参
- `T(args...)`：使用参数包构造 `T` 类型的对象，实现原地构造

### 4.3 优势与应用场景
- **效率更高**：避免了 `push_back()` 所需的临时对象创建和复制操作
- **使用方便**：可以直接传递构造函数的参数，无需显式创建对象

示例：
```cpp
MyVec<pair<int, double>> a;
a.emplace_back(1, 3.1);  // 直接传递pair构造函数的参数
// 等价于 a.push_back(pair<int, double>(1, 3.1)); 但更高效
```

## 五、必要声明
低版本C++需要用到
```C++
class iterator {
   private:
    T* ptr;
   public:
   using value_type = T; // 要使用STL算法，需要用value_type声明数据类型
   using iterator_category = random_access_iterator_tag; // 声明迭代器类型为可随机访问迭代器
   using difference_type =  ptrdiff_t;// 计算两个迭代器的距离的方式
   using pointer = T*; // 声明pointer类型
   using reference = T*; // 声明引用类型
   // 低版本C++，要把上述内容都声明一遍才能使用reverse
   ...
```
