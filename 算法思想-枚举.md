---
date: 2025-07-16
tags:
  - 编程
  - Cpp
  - 计算机
  - 算法
  - 枚举
  - 前缀和
  - 差分
---
# 枚举算法的定义
- 在某个可能的==解的集合==中，按某个==顺序==依次检索元素，用题目给定的条件进行==校验==或==计算==
	- 案例：给定一个数组判断是否存在奇数
		- 解的集合->数组
		- 顺序->任意，正向/反向
		- 校验->是否是奇数
# 枚举基础模型
- ==any of==枚举--“是否存在”的问题
- ==find if==枚举--找到第一个符合条件的元素
- ==all of==枚举--全部都
- ==none of==枚举--全部都不
- ==max_element==
- ==min_element==
- ==accumulate==


# 枚举优化
- 通过裁剪枚举集来减少枚举次数

# 常见简单枚举类型

## 按位枚举
- 即枚举一个整数的每一位
```C++
while (x) {
	int digit = x % 10;
	// do something
	x /= 10;
}
for (; x; x /= base) { //for 写法，base进制的按位枚举
 int digit = x%base;
 //do something
}
```
- 将枚举出的数字存放到数组中就是进制转换

## 子串匹配枚举
- 在一个数组中，判断是否存在子数组等于目标数组
	- 子数组：从原数组中按顺序取出若干个元素组成新数组
- 当目标数组长度为1-->find if模型
- 目标长度>1：找到第一个元素后，再用find if模型判断第二个元素，直到目标数组所有元素都被找到
```C++
size_t idx = 0; // 记录当前已经匹配到目标数组的第几个元素
for (auto &elem : arr) {
	if (elem == target[idx]) {
		idx ++;
		if (idx == target.size()) return true;
	}
}
```
- 模板函数，可以适用任意类型的vector和string
```C++
template <typename T>
bool subMatch(const T &arr, const T &target) {
	size_t idx = 0; // 记录当前已经匹配到目标数组的第几个元素
	for (auto &elem : arr) {
		if (elem == target[idx]) {
			idx ++;
			if (idx == target.size()) return true;
		}
	}
	return false;
}
```


# 前缀和算法

## 基本概念
- 前缀和是用于询问区间和的高效算法
## 一般实现
- 将前i个元素的和存放在另一个数组中
```C++
vector<int> preifx(n); // 前缀和数组
int sum = 0;
for (int i = 0; i < n ; i++){
	sum += arr[i];
	prefix[i] = sum;
} 
```
- `prefix[i]`代表`arr`中0-i的和
- 如果想要求`arr`中4-8的和，只需要`prefix[8]-prefix[3]`即可，不需要再次遍历
- 只需要用$O\left( n \right)$的复杂度处理前缀和，再用$O\left( 1 \right)$的复杂度就可以求出任意区间的和
- 公式`sum(L,R) = prefix(R) - prefix(L-1)`
- 优化的代码写法：
```C++
vector<int> prefix(n);
for (int i = 0; i < n; i++) {
	// prefix[i] = prefix[i-1] + arr[i]; 基本思路，但是i=0需要特殊处理
	if (i) prefix[i] = prefix[i-1];
	prefix[i] += arr[i];
}
```
- C++提供了系统库函数`partial_sum(begin,end,pos);`（在`numeric`库中）
	- `begin` 前缀起始
	- `end`前缀终止
	- `pos`将计算结果存储到的目标位置，vector和普通数组都实用
	- 示例`partial_sum(arr.begin(),arr.end(),prefix.begin())`
		- 直接代替上面的for循环，得到一整个前缀和数组
### 查询
- 处理L=0时`prefix[L-1]`越界问题
	- 让L从1开始
		- `partial_sum(arr.begin(),arr.end(),prefix.begin()+1)`
	- 对L=0进行特判

## 变种模型
- 满足结合律和可逆运算
### 前缀积
- `mul(L,R) = prefix[R]/prefix[L-1]`
- 前缀积很容易变大导致数据溢出
- 可以由`partial_sum`结合匿名函数实现
```C++
partial_sum(arr.begin(),arr.end(),xorsum.begin(),[](int prev, int cur){
	return prev ^ cur;
});
```
#### 乘法逆元
- 通常对结果进行**取模**，规避高精度运算（此时之前的运算规则失效）
	- `prefix[i] = prefix[i-1] * arr[i] % mod`
	- 逆运算：**乘法逆元**（费马小定理，快速幂）
### 前缀异或
- `xor(L,R) = prefix[R] ^ prefix[L-1]` 
- 性质：如果有两个前缀异或和相同，代表这一段区间的异或和为0，如果有多个数字相同，任选两个数字所形成的区间异或和都为0
	- 可以通过组合数快速求出数组中有多少段区间的异或和是0$\sum_{}C_{cnt}^{2}=\sum \frac{cnt\left( cnt-1 \right)}{2}$
	- 不取任何元素的前缀是0，记得在前缀数组中最前面加上，少了会出现漏统计
- 代码实现
```C++
partial_sum(arr.begin(),arr.end(),xorsum.begin(),[](int prev, int cur){
	return prev ^ cur;
});
```

### 二维前缀
- 在二维矩阵中快速求出任意子矩阵的和
- 先对每一行求前缀和，再对每一列求前缀和
- 二维前缀和数组中的元素代表**原数组中左上角到当前位置所有元素的和**
- 求子矩阵和图例
![[Pasted image 20250718120732.png]]
- 公式`sum(x1,y1,x2,y2)=p[x2][y2] - p[x2][y1-1] - p[x1-1][y2] + p[x1-1][y1-1]`

- **二维前缀的初始化：当前元素 + 左 + 上 - 左上的前缀和**
```C++
auto s = vector(n + 1, vector<int>(m + 1));
// 先算行再算列
for (int i = 1; i <= n; i++) {
  partial_sum(a[i].begin(), a[i].end(), s[i].begin());
  for (int j = 1; j <= m; j++) {
    s[i][j] = s[i][j] + s[i - 1][j];
  }
}

// 当前元素 + 左 + 上 - 左上的前缀和
for (int i = 1; i <= n; i++) {
  for (int j = 1; j <= m; j++) {
    s[i][j] = a[i][j] + s[i - 1][j] + s[i][j - 1] - [i - 1][j - 1];
  }
}
```

### 普遍前缀
- 表示开始到当前位置的运算结果，运算任意
	- 如前缀最大值/前缀最小值
	- 没有对应逆运算无法用于求解区间问题
- 应用于某些需要**多次查询起点到目标位置的某个统计信息**的题目
- 对于后缀运算在`partial_sum`迭代器中使用`.rbegin()`和`.rend()`即可
```C++
partial_sum(arr.rbegin(), arr.rend(), suffix.rbegin(), 
	[](int prev, int cur) {
		if (cur) return prev + cur;
		return cur;
	})
```

## 总结

**前缀和**：快速计算区间和
**前缀运算**：结合律，可逆运算，如乘法，异或
**二位前缀**：快速计算子矩阵和，容斥原理
**普遍前缀**：任意运算的统计，可适用于后缀

# 差分算法
- 差分是用于**快速处理区间加减**操作的算法，是**前缀和的逆运算**
- 前缀和$s_{i}=\begin{cases}a_{i} &   & , i=0 \\a_{i}+s_{i-1} &  & ,i>0\end{cases}$；差分$d_{i}=\begin{cases}a_{i} &  & ,i=0 \\a_{i}-a_{i-1} &  & ,i>0\end{cases}$
```C++
for(int i = n - 1; i >= 0; i--) { //从后往前遍历
	if (i == 0) d[i] = a[i];
	else d[i] = a[i] - a[i-1]
}
adjacent_difference(a.begin(),a.end(),d.begin()); // 系统库函数
```

## 常用推论
- 对一个数组进行一次前缀和再进行一次差分会得到原来的数组
- 对`[l,r]`区间内每个元素都`+k`，等价于对差分数组`l`的位置`+k`，`r+1`的位置`-k`
![[Pasted image 20250723101735.png]]

## 二维差分
- 当前元素-左-上+左上
```C++
auto d = vector(n + 1, vector<int>(m + 1));
for (int i = n; i >= 1; i--) { //先计算列再计算行
    for (int j = m; j >= 1; j--) {
        d[i][j] = a[i][j] - a[i - 1][j];
    }
    adjacent_difference(d[i].begin(), d[i].end(), d[i].begin());
}

for (int i = n; i >= 1; i--) {
    for (int j = m; j >= 1; j--) {
        d[i][j] = a[i][j] - a[i - 1][j] - a[i][j - 1] + a[i - 1][j - 1];
    } //当前元素-左-上+左上
}
```

### 区间修改
![[Pasted image 20250723102428.png]]
- `d[x1][y1]+=k;d[x2+1][y1]-=k;d[x1][y2+1]-=k;d[x2+1][y2+1]+=k;`
	- 只有左上角和原来重合，左下，右上，右下都要出去一格
	- **左上和右下`+k`左下和右上`-k`**
- 由$O(n^2)$的枚举修改优化为$O(1)$

## 扩展推论
- 适用于前缀和的运算也适用于差分，如**异或**，**乘法取模**
![[Pasted image 20250723102858.png]]
- 一些有规律的累加可以使用多重差分 ^e003ca
	- 例如想要在一个区间进行等差数列的累加$a_{0}=3,d=2,n=5$，`[3,5,7,9,11,0,0]`对应操作`[+3,-1,0,0,0,-13,+11]`,进行两次前缀和就可以得到原数组，正向推导非常困难，所以逆向推导则是对原来的等差数列进行多次差分，得到只有常数个非零元素的数组。
	- 当需要**对区间进行某种较为特殊的修改**时，只需要构造对应数组，然后尝试差分，直到得到一个只有常数个非零元素的数组就可以将操作优化到$O(1)$
	- 任何符合**多项式的累加**，都可以经过**最高项+1次差分**得到一个常数级的修改方案
- 差分数组的正负性可以反应原数组的增减性（排除第一个元素进行讨论） ^57e4f2
	- 任选`[L,R]`，让所有元素增加或减少，使得数组递增、递减或相等->让差分数组任选两个位置，一个加一个减，使得数组变成正数、负数或0。
		- 例如让一个数组的元素变成全部相同的最少操作数，就是不看差分数组头尾，统计差分数组中`max(正数和,负数和)`，得到的数字就是最少操作数。
- 对于二维的多次差分需要将**对角线分开**来看进行操作

![[Pasted image 20260207110119.png]]



# 单调性枚举

## 引入例题 LeetCode 209
### 题目内容
有正整数数组$arr$和目标值$target$，求最小的区间，数字之和$\geq target$

### 朴素写法
枚举左端点和右端点，再求和。
加点前缀和优化也需要$O(n^2)$

### 单调性枚举的优化

![[Pasted image 20260210090946.png]]

把枚举的情况列成表格观察，绿色格子是**每一层的最小区间**，发现三个性质
1. 绿色格子左边的都不符合$\geq target$的条件
2. 绿色格子右边的都符合条件
3. **右端点是单调递增的（$r_{i}\leq r_{i+1}$）**
	1. 任意选一个绿色格子右边的格子，以$(2,3)$为例
	2. $(2,3)$下面的格子$(3,3)$一定比$(2,3)$更小，更不会符合条件
	3. 所以在$l=3$的条件下，一定要在$(3,3)$的右边才能找到绿色格子，即$r\geq4$
	4. 于是可以知道一定有$r_{i}\leq r_{i+1}$

- 由性质$r_{i}\leq r_{i+1}$性质，增加一个`rightIndex`数组记录第一个符合条件的右端点，第二层枚举就从`rightIndex[l - 1]`开始，然后记录本次的右端点记入`rightIndex[l] = r`

![[Pasted image 20260210092132.png|500]]

复杂度优化到$O(n)$

## 算法介绍

对于属于两个有限集的二元组$$(x, y) \in X \times Y$$ 如果存在条件函数
$$f : X \times Y \to \{\text{False}, \text{True}\}$$
使得$$x_i < x_{i+1} \implies y_i \leq y_{i+1}$$
**则称这个模型符合二元组的单调性枚举**，可以通过$O(|X|+|Y|)$的复杂度解决问题，其中$y_{i}$的定义是**满足条件的最小值或者不满足条件的最大值**

## 常见类型
![[Pasted image 20260210093243.png]]

一般来说，只需要证明，对于任意一个区间，**去掉左端点的元素，可能会让满足变不满足，但一定不会让不满足变成满足，去掉右端点则反过来**

![[Pasted image 20260210093552.png]]

- 常见场景
	- 区间求和/区间长度
	- 时间、数轴上的窗口
	- 字符串包含关系（子串/子序列）

## 适用条件与思维模板
- 适用条件
	- 条件函数对区间具有**单调性**（左端点右移只会让条件变难或变易）
	- 维护量可以**在加一个元素/删一个元素时 $O(1)$ 更新**
	- 对于区间和类问题，通常需要数组元素**非负**才能保证单调性
- 思维模板（单调递增枚举）
	1. 固定左端点 $l$，找到最小的 $r$ 使得条件成立
	2. 证明 $r(l)$ 随 $l$ 单调不减
	3. 用双指针同步推进，整体 $O(n)$
- 思维模板（单调递减枚举）
	1. 固定一侧，另一侧朝相反方向移动
	2. 条件满足时指针向“更难满足”的方向收缩
	3. 条件不满足时指针向“更容易满足”的方向扩张

## 判定与维护细节
- 维护量示例
	- 区间和：`sum += arr[r]` / `sum -= arr[l]`
	- 计数/频次：`cnt[x]++` / `cnt[x]--`，配合重复标记
	- 最大/最小值：用单调队列维护窗口极值
- match/update 的常见语义
	- match：当前 `[l, r]` 是否满足条件
	- update：当区间满足时更新答案（最短/最长/计数）
- 容易出错的点
	- `r` 可能越界，更新答案前先判 `r <= e`
	- 更新答案时区间是 `[l, r)` 还是 `[l, r]` 需统一
	- 窗口为空时（`l == r`）需要先扩张

## 编写实现

**四个关键点**：
1. 判断是否满足条件
2. `r`往后移动（增加一个元素时，如何维护区间关键值）
3. `l`往后移动（删除一个元素时，如何维护区间关键值）
4. 找到满足条件的区间时如何更新答案
![[Pasted image 20260210094320.png|400]]

### 抽象为模板函数

```Cpp
/**
 * 单调性枚举（区间）模版
 * [s, e] 闭区间
 * match 判断是否满足条件
 * insert 插入右端点
 * remove 删除左端点
 * update 更新答案
 *    [l, r] 是不满足条件的最大区间
 *           如果在 update 时需要使用维护的关键值，因为维护的关键值包含了 r+1，所以需要删除 r+1 进行更新后再加回去
 *    [l, r+1] 是满足条件的最小区间
 *             使用时需要判断 r+1 是否越界
 */
template<typename M, typename I, typename R, typename U>
void increase_enumerate(int s, int e,
                        const M& match,
                        const I& insert,
                        const R& remove,
                        const U& update) {
  for (int l = s, r = s; l <= e; ) {
    while (l == r || (r <= e && !match(l, r - 1))) insert(l, r++);
    if (match(l, r - 1)) update(l, r - 2);
    else update(l, r - 1);
    remove(l++, r);
  }
}
```

- 返回的`l`和`r`是不满足条件的最大区间

应用到例题：
![[Pasted image 20260210095721.png|400]]

![[Pasted image 20260210100921.png|500]]

![[Pasted image 20260210101048.png|500]]

### 例题讲解
#### LeetCode 209 最小长度子数组和
- 条件：区间和 `>= target`（元素非负，保证单调性）
- 维护：`sum` 加右减左
- 更新：满足时更新最小长度，然后收缩左端点

#### LeetCode 3 无重复字符的最长子串
- 条件：窗口内存在重复字符
- 维护：`cnt[char]`，当某字符计数到 2 标记 `same = true`
- 更新：当无重复时更新最大长度，若有重复则收缩

#### LeetCode 167 两数之和 II（有序数组）
- 条件：`arr[l] + arr[r]` 与 `target` 比较
- 维护：不需要额外结构，直接移动指针
- 更新：等于时返回答案

#### LeetCode 611 有效三角形的个数
- 先排序，固定最大边 `i`
- 条件：`arr[l] + arr[r] > arr[i]` 成立时，`[l, r)` 都成立
- 更新：累加 `r - l`，再收缩右指针

### 单调递减枚举
![[Pasted image 20260210101312.png|500]]

## 典型例题
- LeetCode 209 最小长度子数组和（区间和 >= target）
- LeetCode 3 无重复字符的最长子串（窗口内是否有重复）
- LeetCode 167 两数之和 II（有序数组夹逼）
- LeetCode 611 有效三角形的个数（排序后固定一边，移动双指针）

## 单调性剪枝

- 通过单调性来减少枚举次数
![[Pasted image 20260210101636.png|500]]

也就是所谓的"双指针“，”滑动窗口“

## 总结

- **单调递增枚举**：**二元组满足条件的最小值，单调递增**
	- *四类求值*：最小满足，最大不满足，满足/不满足方案数
	- *公式化*：关键值，条件，维护，更新
- **单调递减枚举**：二元组满足条件的最小值，单调递减
- **单调性剪枝**：左边或下边比当前差，不用枚举
