---
date: 2025-07-16
tags:
  - 编程
  - Cpp
  - 计算机
  - 算法
  - 枚举
  - 前缀和
  - 差分
---
# 枚举算法的定义
- 在某个可能的==解的集合==中，按某个==顺序==依次检索元素，用题目给定的条件进行==校验==或==计算==
	- 案例：给定一个数组判断是否存在奇数
		- 解的集合->数组
		- 顺序->任意，正向/反向
		- 校验->是否是奇数
# 枚举基础模型
- ==any of==枚举--“是否存在”的问题
- ==find if==枚举--找到第一个符合条件的元素
- ==all of==枚举--全部都
- ==none of==枚举--全部都不
- ==max_element==
- ==min_element==
- ==accumulate==


# 枚举优化
- 通过裁剪枚举集来减少枚举次数

# 常见简单枚举类型

## 按位枚举
- 即枚举一个整数的每一位
```C++
while (x) {
	int digit = x % 10;
	// do something
	x /= 10;
}
for (; x; x /= base) { //for 写法，base进制的按位枚举
 int digit = x%base;
 //do something
}
```
- 将枚举出的数字存放到数组中就是进制转换

## 子串匹配枚举
- 在一个数组中，判断是否存在子数组等于目标数组
	- 子数组：从原数组中按顺序取出若干个元素组成新数组
- 当目标数组长度为1-->find if模型
- 目标长度>1：找到第一个元素后，再用find if模型判断第二个元素，直到目标数组所有元素都被找到
```C++
size_t idx = 0; // 记录当前已经匹配到目标数组的第几个元素
for (auto &elem : arr) {
	if (elem == target[idx]) {
		idx ++;
		if (idx == target.size()) return true;
	}
}
```
- 模板函数，可以适用任意类型的vector和string
```C++
template <typename T>
bool subMatch(const T &arr, const T &target) {
	size_t idx = 0; // 记录当前已经匹配到目标数组的第几个元素
	for (auto &elem : arr) {
		if (elem == target[idx]) {
			idx ++;
			if (idx == target.size()) return true;
		}
	}
	return false;
}
```


# 前缀和算法

## 基本概念
- 前缀和是用于询问区间和的高效算法
## 一般实现
- 将前i个元素的和存放在另一个数组中
```C++
vector<int> preifx(n); // 前缀和数组
int sum = 0;
for (int i = 0; i < n ; i++){
	sum += arr[i];
	prefix[i] = sum;
} 
```
- `prefix[i]`代表`arr`中0-i的和
- 如果想要求`arr`中4-8的和，只需要`prefix[8]-prefix[3]`即可，不需要再次遍历
- 只需要用$O\left( n \right)$的复杂度处理前缀和，再用$O\left( 1 \right)$的复杂度就可以求出任意区间的和
- 公式`sum(L,R) = prefix(R) - prefix(L-1)`
- 优化的代码写法：
```C++
vector<int> prefix(n);
for (int i = 0; i < n; i++) {
	// prefix[i] = prefix[i-1] + arr[i]; 基本思路，但是i=0需要特殊处理
	if (i) prefix[i] = prefix[i-1];
	prefix[i] += arr[i];
}
```
- C++提供了系统库函数`partial_sum(begin,end,pos);`（在`numeric`库中）
	- `begin` 前缀起始
	- `end`前缀终止
	- `pos`将计算结果存储到的目标位置，vector和普通数组都实用
	- 示例`partial_sum(arr.begin(),arr.end(),prefix.begin())`
		- 直接代替上面的for循环，得到一整个前缀和数组
### 查询
- 处理L=0时`prefix[L-1]`越界问题
	- 让L从1开始
		- `partial_sum(arr.begin(),arr.end(),prefix.begin()+1)`
	- 对L=0进行特判

## 变种模型
- 满足结合律和可逆运算
### 前缀积
- `mul(L,R) = prefix[R]/prefix[L-1]`
- 前缀积很容易变大导致数据溢出
- 可以由`partial_sum`结合匿名函数实现
```C++
partial_sum(arr.begin(),arr.end(),xorsum.begin(),[](int prev, int cur){
	return prev ^ cur;
});
```
#### 乘法逆元
- 通常对结果进行**取模**，规避高精度运算（此时之前的运算规则失效）
	- `prefix[i] = prefix[i-1] * arr[i] % mod`
	- 逆运算：**乘法逆元**（费马小定理，快速幂）
### 前缀异或
- `xor(L,R) = prefix[R] ^ prefix[L-1]` 
- 性质：如果有两个前缀异或和相同，代表这一段区间的异或和为0，如果有多个数字相同，任选两个数字所形成的区间异或和都为0
	- 可以通过组合数快速求出数组中有多少段区间的异或和是0$\sum_{}C_{cnt}^{2}=\sum \frac{cnt\left( cnt-1 \right)}{2}$
	- 不取任何元素的前缀是0，记得在前缀数组中最前面加上，少了会出现漏统计
- 代码实现
```C++
partial_sum(arr.begin(),arr.end(),xorsum.begin(),[](int prev, int cur){
	return prev ^ cur;
});
```

### 二维前缀
- 在二维矩阵中快速求出任意子矩阵的和
- 先对每一行求前缀和，再对每一列求前缀和
- 二维前缀和数组中的元素代表**原数组中左上角到当前位置所有元素的和**
- 求子矩阵和图例
![[Pasted image 20250718120732.png]]
- 公式`sum(x1,y1,x2,y2)=p[x2][y2] - p[x2][y1-1] - p[x1-1][y2] + p[x1-1][y1-1]`

### 普遍前缀
- 表示开始到当前位置的运算结果，运算任意
	- 如前缀最大值/前缀最小值
	- 没有对应逆运算无法用于求解区间问题
- 应用于某些需要**多次查询起点到目标位置的某个统计信息**的题目
- 对于后缀运算在`partial_sum`迭代器中使用`.rbegin()`和`.rend()`即可
```C++
partial_sum(arr.rbegin(), arr.rend(), suffix.rbegin(), 
	[](int prev, int cur) {
		if (cur) return prev + cur;
		return cur;
	})
```

## 总结

**前缀和**：快速计算区间和
**前缀运算**：结合律，可逆运算，如乘法，异或
**二位前缀**：快速计算子矩阵和，容斥原理
**普遍前缀**：任意运算的统计，可适用于后缀

# 差分算法
- 差分是用于**快速处理区间加减**操作的算法，是**前缀和的逆运算**
- 前缀和$s_{i}=\begin{cases}a_{i} &   & , i=0 \\a_{i}+s_{i-1} &  & ,i>0\end{cases}$；差分$d_{i}=\begin{cases}a_{i} &  & ,i=0 \\a_{i}-a_{i-1} &  & ,i>0\end{cases}$
```C++
for(int i = n - 1; i >= 0; i--) { //从后往前遍历
	if (i == 0) d[i] = a[i];
	else d[i] = a[i] - a[i-1]
}
adjacent_difference(a.begin(),a.end(),d.begin()); // 系统库函数
```

## 常用推论
- 对一个数组进行一次前缀和再进行一次差分会得到原来的数组
- 对`[l,r]`区间内每个元素都`+k`，等价于对差分数组`l`的位置`+k`，`r+1`的位置`-k`
![[Pasted image 20250723101735.png]]

## 二维差分
- 当前元素-左-上+左上
```C++
auto d = vector(n + 1, vector<int>(m + 1));
for (int i = n; i >= 1; i--) { //先计算列再计算行
    for (int j = m; j >= 1; j--) {
        d[i][j] = a[i][j] - a[i - 1][j];
    }
    adjacent_difference(d[i].begin(), d[i].end(), d[i].begin());
}
for (int i = n; i >= 1; i--) {
    for (int j = m; j >= 1; j--) {
        d[i][j] = a[i][j] - a[i - 1][j] - a[i][j - 1] + a[i - 1][j - 1];
    } //当前元素-左-上+左上
}
```

### 区间修改
![[Pasted image 20250723102428.png]]
- `d[x1][y1]+=k;d[x2+1][y1]-=k;d[x1][y2+1]-=k;d[x2+1][y2+1]+=k;`左上和右下`+k`左下和右上`-k`
- 由$O(n^2)$的枚举修改优化为$O(1)$

## 扩展推论
- 适用于前缀和的运算也适用于差分，如**异或**，**乘法取模**
![[Pasted image 20250723102858.png]]
- 一些有规律的累加可以使用多重差分 ^e003ca
	- 例如想要在一个区间进行等差数列的累加$a_{0}=3,d=2,n=5$，`[3,5,7,9,11,0,0]`对应操作`[+3,-1,0,0,0,-13,+11]`,进行两次前缀和就可以得到原数组，正向推导非常困难，所以逆向推导则是对原来的等差数列进行多次差分，得到只有常数个非零元素的数组。
	- 当需要对区间进行某种较为特殊的修改时，只需要构造对应数组，然后尝试差分，直到得到一个只有常数个非零元素的数组就可以将操作优化到$O(1)$
	- 任何符合**多项式的累加**，都可以经过**最高项+1次差分**得到一个常数级的修改方案
- 差分数组的正负性可以反应原数组的增减性（排除第一个元素进行讨论） ^57e4f2
	- 任选`[L,R]`，让所有元素增加或减少，使得数组递增、递减或相等->让差分数组任选两个位置，一个加一个减，使得数组变成正数、负数或0。
		- 例如让一个数组的元素变成全部相同的最少操作数，就是不看差分数组头尾，统计差分数组中`max(正数和,负数和)`，得到的数字就是最少操作数。
- 对于二维的多次差分需要将对角线分开来看进行操作