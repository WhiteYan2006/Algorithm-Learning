---
date: 2025-07-20
tags:
  - 编程
  - 习题
  - 算法
  - 前缀和
  - Cpp
  - 枚举
---

![[Pasted image 20250720114030.png]]

# 实现
## 思路
![[Drawing 2025-07-20 11.46.35.excalidraw]]
## 代码

### 我写的
```Cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
  int n, m;
  cin >> n >> m;
  vector<int> holes(5000000);
  int start_index = 2000000;
  for(int i = 0; i < n; i++) {
    int idx;
    cin >> idx;
    holes[start_index + idx]++;
  }
  partial_sum(holes.begin(), holes.end(), holes.begin());
  int max_startFromL = 0;
  int max_startFromR = 0;
  for (int lStep = 0; lStep < m / 2; lStep++) {
    max_startFromL = max(holes[start_index + m - 2 * lStep] - holes[start_index - lStep - 1], max_startFromL);
  }
  for (int rStep = 0; rStep < m / 2; rStep++) {
    max_startFromR = max(holes[start_index + rStep] - holes[start_index - m + 2 * rStep - 1], max_startFromR);
  }
  cout << max(max_startFromL, max_startFromR) << endl;
}
```

### 参考答案
```C++
#include <bits/stdc++.h>
using namespace std;
int main() {
  int offset = 1e6 + 1;
  int n, m;
  cin >> n >> m;
  vector<int> sum(offset * 2);
  while (n--) {  // 输入坐标
    int x;
    cin >> x;
    sum[x + offset]++;  // 用坐标为下标，要加上偏移量
  }
  partial_sum(sum.begin(), sum.end(), sum.begin());
  int ans = 0;
  for (int step = 0; step * 2 <= m; step++) {
    // 先往左走的情况
    int l = -step + offset;
    int r = m - step * 2 + offset;
    ans = max(ans, sum[r] - sum[l - 1]);
    // 先往右走的情况
    r = step + offset;
    l = -(m - step * 2) + offset;
    ans = max(ans, sum[r] - sum[l - 1]);
  }
  cout << ans << endl;
  return 0;
}
```