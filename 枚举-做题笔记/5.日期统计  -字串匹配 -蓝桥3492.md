---
date: 2025-07-17
tags:
  - 蓝桥杯
  - 枚举
  - 算法
  - 字串匹配
  - 日期类
  - 输入预处理
  - 习题
---

# 问题描述

小蓝现在有一个长度为 100 的数组，数组中的每个元素的值都在 0 到 9 的范围之内。数组中的元素从左至右如下所示：

```text
5 6 8 6 9 1 6 1 2 4 9 1 9 8 2 3 6 4 7 7 5 9 5 0 3 8 7 5 8 1 5 8 6 1 8 3 0 3 7 9 2
7 0 5 8 8 5 7 0 9 9 1 9 4 4 6 8 6 3 3 8 5 1 6 3 4 6 7 0 7 8 2 7 6 8 9 5 6 5 6 1 4 0 1
0 0 9 4 8 0 9 1 2 8 5 0 2 5 3 3
```

现在他想要从这个数组中寻找一些满足以下条件的子序列：

1. 子序列的长度为 8；
2. 这个子序列可以按照下标顺序组成一个 yyyymmdd 格式的日期，并且要求这个日期是 2023 年中的某一天的日期，例如 20230902，20231223。yyyy 表示年份，mm 表示月份，dd 表示天数，当月份或者天数的长度只有一位时需要一个前导零补充。

请你帮小蓝计算下按上述条件一共能找到多少个**不同**的 2023 年的日期。对于相同的日期你只需要统计一次即可。

# 答案提交

这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。

# 实现
## 输入预处理
```C++
#include<bits.stdc++.h>
int main() {
	string str;
	freopen("output.txt","w",stdout); // 将标准输出重定向到文件
	while (cin >> str) {
		cout << "\"" << str << "\"," endl;
	}
	freopen("CON","w",stdout); //恢复标准输入输出
}
```
## 算法实现
```C++
#include <bits/stdc++.h>
using namespace std;

vector<int> digits = {5, 6, 8, 6, 9, 1, 6, 1, 2, 4, 9, 1, 9, 8, 2, 3, 6, 4, 7, 7, 5, 9, 5, 0, 3, 8, 7, 5, 8, 1, 5, 8, 6, 1, 8, 3, 0, 3, 7, 9, 2, 7, 0, 5, 8, 8, 5, 7, 0, 9, 9, 1, 9, 4, 4, 6, 8, 6, 3, 3, 8, 5, 1, 6, 3, 4, 6, 7, 0, 7, 8, 2, 7, 6, 8, 9, 5, 6, 5, 6, 1, 4, 0, 1, 0, 0, 9, 4, 8, 0, 9, 1, 2, 8, 5, 0, 2, 5, 3, 3};
template <typename T>
bool subMatch(T &arr, T &target) { //字串匹配
  size_t idx = 0;
  for (auto &elem : arr) {
    if (elem == target[idx]) {
      if (++idx == target.size()) return true; //用idx是否等于目标长度来判断是否找到
    }
  }
  return false;
}

int main() {
  vector<int> dayInMonths = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
  int cnt = 0;
  for (int month = 1; month <= 12; ++month) {
    for (int day = 1; day <= dayInMonths[month]; ++day) {
      vector<int> target = {2, 0, 2, 3, month / 10, month % 10, day / 10, day % 10}; //有前导0的月份/日期处理方式   
      cnt += subMatch(digits, target);
    }
  }
  cout << cnt << endl;
}
```