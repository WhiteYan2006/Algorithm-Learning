---
date: 2025-07-25
tags:
  - 编程
  - Cpp
  - 差分
  - 前缀和
  - 二维差分
  - 二维前缀和
  - 算法
  - 枚举
  - 习题
---
给你一个 `m x n` 的二进制矩阵 `grid` ，每个格子要么为 `0` （空）要么为 `1` （被占据）。

给你邮票的尺寸为 `stampHeight x stampWidth` 。我们想将邮票贴进二进制矩阵中，且满足以下 **限制** 和 **要求** ：

1. 覆盖所有 **空** 格子。
2. 不覆盖任何 **被占据** 的格子。
3. 我们可以放入任意数目的邮票。
4. 邮票可以相互有 **重叠** 部分。
5. 邮票不允许 **旋转** 。
6. 邮票必须完全在矩阵 **内** 。

如果在满足上述要求的前提下，可以放入邮票，请返回 `true` ，否则返回 `false` 。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/11/03/ex1.png)

**输入：**grid = `[[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]]`, stampHeight = 4, stampWidth = 3
**输出：**true
**解释：**我们放入两个有重叠部分的邮票（图中标号为 1 和 2），它们能覆盖所有与空格子。

**示例 2：**

![](https://assets.leetcode.com/uploads/2021/11/03/ex2.png)

**输入：**grid = `[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]]`, stampHeight = 2, stampWidth = 2 
**输出：**false 
**解释：**没办法放入邮票覆盖所有的空格子，且邮票不超出网格图以外。

**提示：**

- `m == grid.length`
- `n == grid[r].length`
- `1 <= m, n <= 105`
- `1 <= m * n <= 2 * 105`
- `grid[r][c]` 要么是 `0` ，要么是 `1` 。
- `1 <= stampHeight, stampWidth <= 105`

# 实现
## 思路
- 先看哪些地方能够放邮票，在`w*h`内有没有被占用的格子，使用二位前缀和判断当前坐标是否为零即可，把能放邮票的地方都放上邮票
- 使用差分表示放邮票操作减少复杂度（即实现在`[w*h]`空间内全部+1）
- 然后判断是否还有空格子
## 代码
```C++
using namespace std;
#include <bits/stdc++.h>
// @lcpr-template-end
// @lc code=start
class Solution {
 public:
  bool possibleToStamp(vector<vector<int>>& grid, int h, int w) {
    int n = grid.size(), m = grid[0].size();
    auto sum = vector(n + 2, vector(m + 2, 0));
    for (int i = 0; i < n; i++) {
      partial_sum(grid[i].begin(), grid[i].end(), sum[i + 1].begin() + 1);
      for (int j = 1; j <= m; j++) {
        sum[i + 1][j] += sum[i][j];
      }
    }
    auto diff = vector(n + 2, vector(m + 2, 0));
    for (int i = 0; i + h <= n; i++) {
      for (int j = 0; j + w <= m; j++) {
        // (i+1,j+1) -> (i+h,j+w)
        int v = sum[i + h][j + w] - sum[i + h][j] - sum[i][j + w] + sum[i][j];
        if (v == 0) {
          diff[i + 1][j + 1]++;
          diff[i + 1][j + w + 1]--;
          diff[i + h + 1][j + 1]--;
          diff[i + h + 1][j + w + 1]++;
        }
      }
    }

    for (int i = 0; i < diff.size(); i++) {
      partial_sum(diff[i].begin(), diff[i].end(), diff[i].begin());
      for (int j = 0; j < diff[i].size(); j++) {
        if (i) diff[i][j] += diff[i - 1][j];
      }
    }

    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        if (grid[i][j] == 0 && diff[i + 1][j + 1] == 0) return false;
      }
    }
    return true;
  }
};
```