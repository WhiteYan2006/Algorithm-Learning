---
date: 2025-07-29
tags:
  - 编程
  - 算法
  - Cpp
  - 差分
  - 枚举
  - 习题
---

# P4552 [Poetize6] IncDec Sequence

## 题目描述

给定一个长度为 $n$ 的数列 ${a_1,a_2,\cdots,a_n}$，每次可以选择一个区间$[l,r]$，使这个区间内的数都加 $1$ 或者都减 $1$。 
  
请问至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列有多少种。

## 输入格式

第一行一个正整数 $n$   
接下来 $n$ 行,每行一个整数,第 $i+1$行的整数表示 $a_i$。

## 输出格式

第一行输出最少操作次数   
第二行输出最终能得到多少种结果

## 输入输出样例 #1

### 输入 #1

```
4
1
1
2
2
```

### 输出 #1

```
1
2
```

## 说明/提示

对于 $100\%$ 的数据，$n\le 100000, 0 \le a_i \le 2^{31}$。

# 实现
## 思路
- 根据[[算法思想-枚举#^57e4f2|正负性]]原理，只需要统计差分数组中除头尾外正数和负数绝对值的最大值即可得到最小操作数。因为头尾两个数字不影响差分可以随意次操作，所以得到的数组数就是`abs(正数和-负数和)+1`，

## 代码
```C++
#include<bits/stdc++.h>
using namespace std;
int main() {
  int n;
  cin >> n;
  vector<long long> a(n);
  for(int i = 0; i < n; i++){
    cin >> a[i];
  }
  adjacent_difference(a.begin(), a.end(), a.begin());
  a[0] = 0; //a[0]不影响差分，可以直接设置为0
  long long pos = 0, neg = 0;
  for (auto &x : a) {
    if (x > 0) pos += x;
    else neg -= x;
  }
  cout << max(pos, neg) << endl;
  cout << abs(pos - neg) + 1 << endl;
}
```

## NOTE

> [!NOTE] 正负性原理
> - 对一个区间$[l,r]$+1或-1，即在差分数组的$l$和$r+1$上进行对应操作，直到差分数组中$[1,n]$**都是零**，则所有元素相同（方便起见把差分数组第一个元素设置成0`a[0]=0`
> - 因为要求最少的操作，而每次操作都是在一个位置+1一个位置-1，所以除头尾外正数和负数绝对值的最大值就是最少的操作数（**每一次操作都在正数和负数中抵消一次**）

> [! important] 最后有多少中可能的数组
> - 在正数或负数被抵消完之后，会得到这样一个数组`[h,0,0,0,0,x,0,0,0,t]`，因为**头尾不影响相等性**，所以为了把`x`变成0，在每一次抵消`x`的操作时可以任选`h`或者`t`进行一次操作，一共操作`x`次，选择`h`操作次数可选的范围是$[0,x]$次，而选择`t`操作的次数则是$x$减去选`h`的操作次数，**所以一共会有$x+1$中操作的可能，所以最后可能的数组数量是$x+1$**，**而$x$的值等于$|\text{正数和}-|\text{负数和}||$**


