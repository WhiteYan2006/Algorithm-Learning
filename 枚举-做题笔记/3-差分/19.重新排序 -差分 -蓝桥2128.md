---
date: 2025-07-25
tags:
  - 编程
  - 算法
  - 差分
  - 枚举
  - 前缀和
  - Cpp
  - 习题
---

# 题目描述

给定一个数组 $A$ 和一些查询 $L_i, R_i$，求数组中第 $L_i$ 至 $R_i$ 个元素之和。

小蓝觉得这个问题很无聊，于是他想重新排列一下数组，使得最终每个查询结果的和尽可能大。小蓝想知道相比原数组，所有查询结果的总和最多可以增加多少？

# 输入格式

输入第一行包含一个整数 $n$。

第二行包含 $n$ 个整数 $A_1, A_2, \dots, A_n$，相邻两个整数之间用一个空格分隔。

第三行包含一个整数 $m$ 表示查询的数目。

接下来 $m$ 行，每行包含两个整数 $L_i, R_i$，相邻两个整数之间用一个空格分隔。

# 输出格式

输出一行包含一个整数表示答案。

# 样例输入

```
5
1 2 3 4 5
2
1 3
2 5
```

# 样例输出
```
4
```
# 样例说明
原来的和为 $6 + 14 = 20$，重新排列为 $(1, 4, 5, 2, 3)$ 后和为 $10 + 14 = 24$，增加了 $4$。

# 实现
## 思路
- 把最大的数字放在查询次数最多的位置
	- 通过差分数组统计查询次数，在`l`的位置+1.在`r+1`的位置-1
- 把查询数组和原数组都从大到小排列，然后对应元素相乘，即可实现把每个元素被查询的次数和元素本身相乘，累加后得到答案

## 代码
```C++
#include <bits/stdc++.h>
using namespace std;
int main() {
  int n;
  cin >> n;
  vector<long long> a(n);
  vector<long long> visit_diff(n + 2);  // 利用差分快速统计每个位置的访问次数
  for (auto& x : a) cin >> x;
  int m;
  cin >> m;
  long long sum = 0;
  vector<long long> prefix(n + 1);
  partial_sum(a.begin(), a.end(), prefix.begin() + 1);
  while (m--) {
    int l, r;
    cin >> l >> r;
    sum += prefix[r] - prefix[l - 1];
    visit_diff[l]++;
    visit_diff[r + 1]--;
  }
  long long max_sum = 0;
  partial_sum(visit_diff.begin() + 1, visit_diff.end() - 1, visit_diff.begin() + 1);
  sort(visit_diff.begin() + 1, visit_diff.end() - 1);
  // 注意前缀和和排序起点和终点，最前面的0和最后面的负数不参与解题
  sort(a.begin(), a.end());
  for(int i = 0; i < n; i++) {
    max_sum += a[i] * visit_diff[i + 1];
  }
  cout << max_sum - sum << endl;
}
```