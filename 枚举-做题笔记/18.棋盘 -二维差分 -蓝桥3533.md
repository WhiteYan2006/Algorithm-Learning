---
date: 2025-07-24
tags:
  - 编程
  - 算法
  - 差分
  - 二维差分
  - Cpp
---
# 棋盘颜色翻转问题

## 问题描述

小蓝拥有一个 `n × n` 大小的棋盘，一开始棋盘上全都是白子。小蓝进行了 `m` 次操作，每次操作会将棋盘上某个范围内的所有棋子的颜色取反（也就是白色棋子变为黑色，黑色棋子变为白色）。请输出所有操作做完后棋盘上每个棋子的颜色。

## 输入格式

输入的第一行包含两个整数 `n`，`m`，用一个空格分隔，表示棋盘大小与操作次数。

接下来 `m` 行每行包含四个整数 `x1`，`y1`，`x2`，`y2`，相邻整数之间使用一个空格分隔，表示将在 `x1` 至 `x2` 行和 `y1` 至 `y2` 列中的棋子颜色取反。

## 输出格式

输出 `n` 行，每行 `n` 个 0 或 1 表示该位置棋子的颜色。如果是白色则输出 0，否则输出 1。

## 样例

### 样例输入
```
3 3
1 1 2 2
2 2 3 3
1 1 3 3
```

### 样例输出
```
001
010
100
```

## 评测用例规模与约定

- 对于 30% 的评测用例：`n, m ≤ 500`
- 对于所有评测用例：`1 ≤ n, m ≤ 2000`，`1 ≤ x1 ≤ x2 ≤ n`，`1 ≤ y1 ≤ y2 ≤ m`

# 实现
## 代码
```C++
#include <bits/stdc++.h>
using namespace std;
int main() {
  int n, m;
  cin >> n >> m;
  auto maze = vector(n + 2, vector(n + 2, 0));
  while (m--) {
    int x1, y1, x2, y2;
    cin >> x1 >> y1 >> x2 >> y2;
    maze[x1][y1]++;
    maze[x2 + 1][y1]--;
    maze[x1][y2 + 1]--;
    maze[x2 + 1][y2 + 1]++;
  }
  for (int i = 1; i <= n; i++) {
    partial_sum(maze[i].begin(), maze[i].end(), maze[i].begin());
    for (int j = 1; j <= n; j++) {
      maze[i][j] += maze[i - 1][j];
      cout << (maze[i][j] & 1);
    }
    cout << endl;
  }
}
```