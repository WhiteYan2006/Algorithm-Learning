---
date: 2025-07-22
tags:
  - 编程
  - 算法
  - Cpp
  - 枚举
  - 前缀和
  - 普遍前缀
  - 枚举优化
  - 习题
---
### 题目描述
给定一个长度为 $N$ 的数列，$A_1, A_2, \cdots A_N$，如果其中一段连续的子序列 $A_i, A_{i+1}, \cdots A_j$（$i \leq j$）之和是 $K$ 的倍数，我们就称这个区间 $[i,j]$ 是 $K$ 倍区间。

你能求出数列中总共有多少个 $K$ 倍区间吗？

### 输入描述
第一行包含两个整数 $N$ 和 $K$（$1 \leq N,K \leq 10^5$）。

以下 $N$ 行每行包含一个整数 $A_i$（$1 \leq A_i \leq 10^5$）

### 输出描述
输出一个整数，代表 $K$ 倍区间的数目。

### 输入输出样例
#### 示例
**输入**
```
5 2
1
2
3
4
5
```

**输出**
```
6
```

# 实现
## 思路
在前缀和数组S中，如果要满足`(s[r]-s[l-1])%k == 0`，即`s[r]%k == s[l-1]%k`
所以通过统计前缀和模k数组中相同的个数，再利用组合数$\sum C_{cnt}^{2}$即可快速得到k倍区间，规避慢速的双层遍历循环

## 代码
```C++
#include <bits/stdc++.h>
using namespace std;
int main()
{
  int n,k;
  cin >> n >> k;
  vector<int> a(n+1);
  for (int i = 1; i <= n; i++) cin >> a[i];
  vector<int> s(n+1);
  for (int i = 1; i <= n; i++) {
    s[i] = (a[i] + s[i-1]) % k; //前缀和模k数组
  }
  vector<int> cnt(k); // %k只有0~k-1的结果
  for (auto &x : s) cnt[x]++;
  long long ans = 0;
  for (auto &c : cnt) ans+=(long long)c*(c-1)/2; // 记得改long long不然会溢出
  cout << ans << endl;
  return 0;
}
```

## Note
**使用`partial_sum`会出错，不知道为什么**
```Cpp
partial_sum(Arr.begin(), Arr.end(), P.begin() + 1, [&](int prev, int cur){
    return (prev + cur) % k;
  });
```

这种**双重循环**会超时
```Cpp
for(int i = 0; i < k; i++) {           // O(k)
    long long temp = 0;
    for(int j = 0; j <= n; j++) {      // O(n)
      if(P[j] == i) temp++;
    }
    cnt += temp * (temp - 1) / 2;
}
```

> [!NOTE]
> - 需要**统计数组里每个元素的个数**时最好**新开一个数组**来统计，避免双重循环超时
> ``` cpp
> vector<int> cnt(k);
> for (auto &x : s) cnt[x] ++;
> ```

