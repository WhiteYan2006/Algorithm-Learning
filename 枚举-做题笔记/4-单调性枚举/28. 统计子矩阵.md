---
date: 2026-02-11
tags:
  - 编程
  - Cpp
  - 算法
  - 枚举
  - 单调性枚举
  - 前缀和
---

# 统计子矩阵（蓝桥杯 2022 省赛 B 组 F / P8783）

## 题目链接


## 题目描述（整理）
给定一个 `N x M` 的非负整数矩阵 `A`，统计有多少个子矩阵满足：
- 子矩阵元素和 `<= K`

其中子矩阵大小最小是 `1 x 1`，最大是 `N x M`。

## 输入格式
- 第一行：`N M K`
- 接下来 `N` 行，每行 `M` 个整数，表示矩阵 `A`

## 输出格式
- 输出一个整数，表示满足条件的子矩阵数量

## 数据范围
- `1 <= N, M <= 500`
- `0 <= A[i][j] <= 1000`
- `1 <= K <= 2.5 x 10^8`

## 样例输入
```text
3 4 10
1 2 3 4
5 6 7 8
9 10 11 12
```

## 样例输出
```text
19
```


# 实现
## 思路
- 先二维前缀和
- **在二维情况下没有单调性**
- 想办法**变成一维**
	- 先枚举`[x1, x2]`的范围，把每一列的和处理出来--$O(n^2)$
	- 再枚举`[y1, y2]`，变成单调性枚举的`[l, r]`形式--$O(n)$
- 实际上就是在`x`上正常进行遍历枚举，然后单独对`y`进行单调性枚举的优化

## 代码
```Cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
  int n, m, k;
  cin >> n >> m >> k;
  auto a = vector(n, vector<int>(m, 0));
  for(auto &line : a) {
    for (auto &x : line) cin >> x;
  }

  auto prefix = vector(n + 2, vector<int>(m + 2, 0)); // 二位前缀和数组
  for(int i = 1; i <= n; i++) {
    partial_sum(a[i - 1].begin(), a[i - 1].end(), prefix[i].begin() + 1);
    for(int j = 1; j <= m; j++) {
      prefix[i][j] += prefix[i - 1][j];
    }
  }
  
  auto matrix_sum = [&](int x1, int y1, int x2, int y2) { // 二维前缀和计算
    return prefix[x2][y2] - prefix[x1 - 1][y2] - prefix[x2][y1 - 1] + prefix[x1 - 1][y1 - 1];
  };

  long long cnt = 0;
  for (int x1 = 1; x1 <= n; x1++) {
    for (int x2 = x1; x2 <= n; x2++) { // O(n^2) 枚举[x1, x2]
      int y1 = 1; // O(n) 单调性枚举[y1, y2]
      for(int y2 = 1; y2 <= m; y2++) { 
        while(y1 <= y2 && matrix_sum(x1,y1,x2,y2) > k) y1++;
        cnt += y2 - y1 + 1; // 以y2为右端点的符合条件的区间个数
      }
    }
  }
  cout << cnt << endl;
}
```

- **公式化单调性枚举**
```Cpp
int main() {
  int n, m, k;
  cin >> n >> m >> k;
  auto a = vector(n, vector<int>(m, 0));
  for(auto &line : a) {
    for (auto &x : line) cin >> x;
  }

  auto prefix = vector(n + 2, vector<int>(m + 2, 0)); // 二位前缀和数组
  for(int i = 1; i <= n; i++) {
    partial_sum(a[i - 1].begin(), a[i - 1].end(), prefix[i].begin() + 1);
    for(int j = 1; j <= m; j++) {
      prefix[i][j] += prefix[i - 1][j];
    }
  }
  
  auto matrix_sum = [&](int x1, int y1, int x2, int y2) { // 二维前缀和计算
    return prefix[x2][y2] - prefix[x1 - 1][y2] - prefix[x2][y1 - 1] + prefix[x1 - 1][y1 - 1];
  };

  long long cnt = 0;
  for (int x1 = 1; x1 <= n; x1++) {
    for (int x2 = x1; x2 <= n; x2++) { // O(n^2) 枚举[x1, x2]
      for(int y1 = 1, y2 = 1; y1 <= m; ) {
        while(y2 <= m && matrix_sum(x1,y1,x2,y2) <= k) {
          y2++;
        } // 注意出去判断区间要用matrix_sum(x1,y1,x2,y2 - 1) 这个区间是最后一个符合条件的区间
        if (matrix_sum(x1,y1,x2,y2 - 1) > k) { // [y1, y2 - 2] 符合条件
          cnt += y2 - y1 - 1;
        } else { // [y1, y2 - 1] 符合条件
          cnt += y2 - y1;
        }
        y1++;
      }
    }
  }
  cout << cnt << endl;
}
```


- **参考答案**
```Cpp
int main() {
  int n, m, k;
  cin >> n >> m >> k;
  auto a = vector(n, vector<int>(m, 0));
  for(auto &line : a) {
    for (auto &x : line) cin >> x;
  }
  long long ans = 0;
  for(int x1 = 0; x1 < n; x1++) {
    vector<int> sum(m); // 统计每一[x1,x2]列的和
    for(int x2 = x1; x2 <= n; x2++) {
      for(int y = 0; y < m; y++) sum[y] += a[x2][y];
      int total = 0;
      for(int y1 = 0, y2 = 0; y1 < m; ) {
        while(y2 < m && total <= k) {
          total += sum[y2++];
        }
        if (total > k) {
          // [y1, y2 - 2] 符合条件
          ans += y2 - 2 - y1 + 1;
        } else {
          // [y1, y2 - 1] 符合条件
          ans += y2 - 1 - y1 + 1;
        }
        total -= sum[y1++];
      }
    }
  }
  cout << ans << endl;
}
```

## Note

> [!Note] *高维度下处理单调性枚举*
> - 高纬度有多个方向，是**不满足单调性的**
> - 必须想办法**降维到一维**

> [!note] 复杂度估算
> - 数据量为500，基本都是$O(n^3)$

> [!important] 单调性枚举的条件判断易错点
> - **注意判断条件**：`if (matrix_sum(x1,y1,x2,y2 - 1) > k)`，**一定要有`-1`**，判断条件要用**最后一个符合条件的区间**，但是出循环时得到的区间是**第一个不符合条件的区间**，***一定要记得“-1”!***

