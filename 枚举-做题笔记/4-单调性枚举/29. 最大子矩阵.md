---
date: 2026-02-12
tags:
  - 编程
  - Cpp
  - 算法
  - 枚举
  - 单调性枚举
  - 单调队列
---

# 最大子矩阵（蓝桥杯 2022 省赛 Java B 组 F / lq2147）

## 题目链接
- https://www.lanqiao.cn/problems/2147/learning/
- 题面镜像（用于核对）：https://www.dotcpp.com/oj/problem2675.html

## 题目描述（整理）
给定一个 `N x M` 的矩阵。

定义一个矩阵 `m` 的稳定度为：
- `f(m) = max(m) - min(m)`

现在要在原矩阵中找一个子矩阵，使得：
- 该子矩阵稳定度 `<= limit`
- 子矩阵面积尽可能大

其中子矩阵指：选一段连续的行、再选一段连续的列，交叉部分组成的矩阵。

## 输入格式
- 第一行：`N M`
- 接下来 `N` 行，每行 `M` 个整数（矩阵元素）
- 最后一行：`limit`

## 输出格式
- 输出一个整数：满足稳定度限制的最大子矩阵面积

## 样例输入
```text
3 4
2 0 7 9
0 6 9 7
8 4 6 4
8
```

## 样例输出
```text
6
```

## 样例说明
满足稳定度不大于 `8` 且面积最大的子矩阵有多个，最大面积都是 `6`。

## 数据范围（题面约定）
- 对所有评测点：`0 <= 矩阵元素值, limit <= 10^5`
- 分组规模（原题分点）：
  - 小规模含 `N, M <= 10`
  - 存在 `N = 1, M <= 10^5` 的长条数据
  - 存在 `N <= 10, M <= 10^4` 的数据
  - 最大规模约 `N, M <= 80`

# 实现
## 思路
- 处理二维单调性，同[[28. 统计子矩阵 -二维单调性枚举 -lq2109|上题]]
- 维护区间内的最大值和最小值，**使用`multiset`来维护**

## 代码
```Cpp
int main() {
  int n, m;
  cin >> n >> m;
  auto a = vector(n, vector<int>(m, 0));
  for (auto& line : a) {
    for (auto& x : line) cin >> x;
  }
  int limit;
  cin >> limit;
  
  int max_area = 0;
  for (int x1 = 0; x1 < n; x1++) {
    vector<int> minInLine(m, INT_MAX);
    vector<int> maxInLine(m, INT_MIN);
    for (int x2 = x1; x2 < n; x2++) {
      for(int y = 0; y < m; y++) {
        minInLine[y] = min(minInLine[y], a[x2][y]);
        maxInLine[y] = max(maxInLine[y], a[x2][y]);
      }
      multiset<int> s; // 维护最大值最小值
      for (int y1 = 0, y2 = 0; y1 < m;) {
        while(y2 < m && (s.empty() || *s.rbegin() - *s.begin() <= limit)) { // s是空的时候直接插入，rbegin和begin在s是空的时候会报错
          s.insert(minInLine[y2]);
          s.insert(maxInLine[y2++]);
        }
        if (!((s.empty() || *s.rbegin() - *s.begin() <= limit))) {
          max_area = max(max_area, (x2 - x1 + 1) * (y2 - 2 - y1 + 1));
        } else {
          max_area = max(max_area, (x2 - x1 + 1) * (y2 - 1 - y1 + 1));
        }
        s.erase(s.find(minInLine[y1])); // 不能s.erase(minInLine[y1])，会删除所有相同元素
        s.erase(s.find(maxInLine[y1++]));
      }
    }
  }
  cout << max_area << endl;
}
```

## Note

> [!important] 如何维护区间中最大值和最小值
> - 需要不断往里塞入内容，还需要删除，还需要获取最大值和最小值
> - **使用`multiset`数据结构**
> 	- `rbegin`获取最大值；`begin`获取最小值

> [!Note] `multiset`使用注意事项
> - **一定要判断是否为空**，不然`rbegin`和`begin`会报错
> - 要`s.erase(s.find(minInLine[y1]))`才能只删一个，如果`s.erase(minInLine[y1])`会删除所有相同元素

> [!warning] `max_element`的区间问题
> - 这个函数是开区间，在我没有修改的错误高复杂度答案中这样写的是**错的**
> ```cpp
> auto get_stability = [](int l, int r, vector<int> &maxInLine, vector<int> &minInLine) {
 >   if (l >= r) return 0;
 >   return *max_element(maxInLine.begin() + l, maxInLine.begin() + r) - 
 >     *min_element(minInLine.begin() + l, minInLine.begin() + r);
  >};
> ```
> - 一定要记得**开区间**，要**+1**
> ```cpp
> auto get_stability = [](int l, int r, vector<int> &maxInLine, vector<int> &minInLine) {
 >   if (l >= r) return 0;
 >   return *max_element(maxInLine.begin() + l, maxInLine.begin() + r + 1) - 
 >     *min_element(minInLine.begin() + l, minInLine.begin() + r + 1);
  >};
> ```

