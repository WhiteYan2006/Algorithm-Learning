---
date: 2026-02-13
tags:
  - 编程
  - Cpp
  - 算法
  - 单调性枚举
---
# P10444 「MYOI-R3」极差

## 题目描述

对于一个序列 $c$ ，定义 $c$ 的极差为 $c$ 中最大值与最小值之差。现在给定一个长度为 $n$ 的序列 $a$，问是否能将其分成至少两个长度大于 $1$ 的子序列，使得每个子序列的极差都相等（注意，所有元素都必须分配且每个元素仅能分配到一个子序列中）。

## 输入格式

**本题包含多组数据**。

第一行两个整数 $T,id$，表示数据组数和子任务编号。

对于每组数据，

第一行一个正整数 $n$，表示数组长度。

第二行 $n$ 个整数表示序列 $a$。

## 输出格式

对于每组数据，输出一行一个字符串 `Yes` 或 `No`。

## 输入输出样例 #1

### 输入 #1

```
2 1
6
1 1 4 5 1 4
7
1 9 1 9 8 1 0
```

### 输出 #1

```
No
Yes
```

## 说明/提示

### 样例 $\small\text{1}$ 解释

样例符合子任务 1 的约束，$id=1$。


询问一：

可以证明，没有任何方案满足条件。

询问二：

合法分配的一种子序列集合如下：
- $\{1,9\}$。
- $\{1,9\}$。
- $\{8,1,0\}$。

答案不唯一。

### 数据规模与约定

**本题采用捆绑测试**。

- Subtask 1（20 points）：$4\le \sum n\le 20,a_i\ge 0$。
- Subtask 2（20 points）：$4\le \sum n\le 100,a_i\ge 0$。
- Subtask 3（20 points）：$4\le \sum n\le 10^3,a_i\ge 0$。
- Subtask 4（10 points）：$a$ 数组中元素相等。
- Subtask 5（30 points）：无特殊限制。


对于 $100\%$ 的数据，$4\le \sum n\le 10^6,0\le |a_i|\le 10^9,1\le T\le 300$。

# 实现
## 思路
- 对于这种和数组**顺序无关**的题目，可以先排序
- 排序后有`[1,1,1,4,5]`，不难发现最大值和最小值肯定会出现在至少两个不同的数组里`[1,];[,5]`
	- 除非有多个最大值和最小值，不然出现在同一个数组里其他的元素凑不够极差，有多个相同最大值和最小值也一样会有两个不同数组里有最大值和最小值
- 先考虑两个子数组情况，对于上面的`[1,];[,5]`，每个子数组里都会有相对的最大值和最小值`[1,max];[min,5]`，要保持极差相等，所以$max - 1=5-min \implies max+min=5+1$
- 相当于除了最大值和最小值外，**原来的数组里是否存在两个数$a,b$使得$a+b=target=max+min$**
- 于是题目就被转换成了**单调递减枚举**

## 代码
```Cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
  int t, id;
  cin >> t >> id;
  while (t--) {
    int n;
    cin >> n;
    vector<long long> a(n);
    for (auto& x : a) cin >> x;
    sort(a.begin(), a.end());
    long long target = a[0] + a[n - 1];
    bool found = false;
    for(int l = 1, r = n - 2; l < r; ) {
      if (a[l] + a[r] >= target) {
        if (a[l] + a[r] == target) {
          cout << "Yes" << endl;
          found = true;
          break;
        }
        r--;
      } else {
        l++;
      }
    }
    if(!found)
    cout << "No" << endl;
  }
}
```

- 使用匿名函数的写法
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
  int t, id;
  cin >> t >> id;
  while (t--) {
    int n;
    cin >> n;
    vector<long long> a(n);
    for (auto& x : a) cin >> x;
    sort(a.begin(), a.end());
    long long target = a[0] + a[n - 1];

    cout << [&]() {
      for (int l = 1, r = n - 2; l < r;) {
        if (a[l] + a[r] > target) {
          r--;
        } else if (a[l] + a[r] < target) {
          l++;
        } else {
          return "Yes";
        }
      }
      return "No";
    }() << endl;
  }
}
```




## Note
> [! Note] 题目**与数组内元素顺序无关时的简化处理**
> - 可以尝试**先排序**，排序后会有更多好的性质

