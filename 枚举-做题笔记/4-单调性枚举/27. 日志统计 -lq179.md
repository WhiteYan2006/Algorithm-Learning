---
date: 2026-02-10
tags:
  - 编程
  - Cpp
  - 算法
  - 枚举
  - 单调性枚举
---

# 日志统计（蓝桥杯 2018 省赛 B 组 / lq179）

## 题目描述（整理）
小明维护一个程序员论坛，有一份“点赞”日志，共有 N 行。每行格式为 `ts id`，表示在时间 `ts` 时，编号为 `id` 的帖子收到一个赞。

如果某个帖子在任意长度为 D 的时间区间内，收到的赞数不少于 K，则该帖子曾经是“热帖”。更严格地说，若存在某个时刻 T，使得该帖在区间 `[T, T + D)`（左闭右开）内的点赞数量 ≥ K，则该帖为热帖。

请根据日志统计所有曾是热帖的帖子编号。

## 输入格式
- 第一行三个整数：`N D K`
- 接下来 N 行，每行两个整数：`ts id`

## 输出格式
按从小到大的顺序输出所有热帖的 `id`，每个 `id` 一行。

## 数据范围
- 对于 50% 的数据：`1 ≤ K ≤ N ≤ 1000`
- 对于 100% 的数据：`1 ≤ K ≤ N ≤ 100000`，且 `0 ≤ ts ≤ 100000`，`0 ≤ id ≤ 100000`

## 样例输入
```
7 10 2
0 1
0 10
10 10
10 1
9 1
100 3
100 3
```

## 样例输出
```
1
3
```

# 实现
## 思路
- 条件: `t[r] - t[l] >= d` 
- 不符合条件的区间，是否有` >= k`的统计
- 从小到大输出id，用set维护

## 代码

```Cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
  // 条件: t[r] - t[l] >= d
  // 不符合条件的区间，是否有 >= k的统计
  // 从小到大输出id，用set维护
  int n, d, k;
  cin >> n >> d >> k;
  auto logs = vector<pair<int, int>>(n); // 输入二元组，用pair维护
  for (auto &[ts, id] : logs) cin >> ts >> id;
  sort(logs.begin(), logs.end()); // 按第一个元素排序（时间）
  vector<int> cnt(100001); // cnt是统计当前时间区间内的点赞数
  set<int> ans;

  for (int l = 0, r = 0; r < n; ) {
    while(r < n && logs[r].first - logs[l].first < d) {
      int id = logs[r++].second;
      cnt[id]++;
      if (cnt[id] == k) ans.insert(id);
    }
    cnt[logs[l++].second]--; // l更新后，当前的l不在新区间内，要把cnt[logs[l].second]减一
  }
  for(auto x : ans) cout << x << endl;
}
```

- 使用模板

```Cpp
#include<bits/stdc++.h>
using namespace std;
template<typename M, typename I, typename R, typename U>
void increase_enumerate(int s, int e,
                        const M& match,
                        const I& insert,
                        const R& remove,
                        const U& update) {
  for (int l = s, r = s; l <= e; ) {
    while (l == r || (r <= e && !match(l, r - 1))) insert(l, r++);
    if (match(l, r - 1)) update(l, r - 2);
    else update(l, r - 1);
    remove(l++, r);
  }
}

int main() {
  int n, d, k;
  cin >> n >> d >> k;
  auto logs = vector<pair<int, int>>(n); // 输入二元组，用pair维护
  for (auto &[ts, id] : logs) cin >> ts >> id;
  sort(logs.begin(), logs.end()); // 按第一个元素排序（时间）
  vector<int> cnt(100001);
  set<int> ans;

  increase_enumerate(0, n - 1, 
    [&](int l, int r) { // 符合条件
      return logs[r].first - logs[l].first >= d;  
    },
    [&](int l ,int r) { //
      cnt[logs[r].second]++;
    },
    [&](int l, int r) {
      cnt[logs[l].second]--;
    },
    [&](int l, int r) {
      if(cnt[logs[l].second] >= k) ans.insert(logs[l].second);
    });

  for(auto x : ans) cout << x << endl;
}
```