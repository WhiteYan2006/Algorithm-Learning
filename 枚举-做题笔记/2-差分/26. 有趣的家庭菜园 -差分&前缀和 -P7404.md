---
date: 2026-02-09
tags:
  - 编程
  - 算法
  - 差分
  - Cpp
  - 枚举
  - 习题
  - 二维差分
  - 前缀和
---
# P7404 [JOI 2021 Final] 有趣的家庭菜园 4 / Growing Vegetables is Fun 4

## 题目描述

给定一个长为 $N$ 的序列 $A$，你可以进行若干次操作：

- 选定一个区间 $[L,R]$，让这个区间里的数加 $1$。

设经过这若干次操作后的序列为 $B$，那么你需要让 $B$ 满足下面这个要求：

- 存在一个整数 $k \in [1,N]$，满足对于子序列 $A_1=\{B_1,B_2,\cdots,B_k\}$ 为严格递增序列，对于子序列 $A_2=\{B_k,B_{k+1},\cdots,B_N\}$ 为严格递减序列。

你想知道最少需要多少次操作才能满足上面这个要求。

## 输入格式

第一行一个整数 $N$ 代表序列长度。

第二行 $N$ 个整数，代表序列 $A$。

## 输出格式

一行一个整数代表最小操作次数。

## 输入输出样例 #1

### 输入 #1

```
5
3 2 2 3 1
```

### 输出 #1

```
3
```

## 输入输出样例 #2

### 输入 #2

```
5
9 7 5 3 1
```

### 输出 #2

```
0
```

## 输入输出样例 #3

### 输入 #3

```
2
2021 2021
```

### 输出 #3

```
1
```

## 输入输出样例 #4

### 输入 #4

```
8
12 2 34 85 4 91 29 85
```

### 输出 #4

```
93
```

## 说明/提示

#### 样例 1 解释

- 对 $[2,5]$ 进行操作，序列变为 $\{3,3,3,4,2\}$。
- 对 $[2,3]$ 进行操作，序列变为 $\{3,4,4,4,2\}$。
- 对 $[3,3]$ 进行操作，序列变为 $\{3,4,5,4,2\}$。

#### 样例 2 解释

序列已经满足要求，不需要操作。

#### 样例 3 解释

对区间 $[1,1]$ 或 $[2,2]$ 进行操作都可。

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（40 pts）：$N \le 2000$。
- Subtask 2（60 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le N \le 2 \times 10^5$，$1 \le A_i \le 10^9$。

#### 说明

翻译自 [The 20th Japanese Olympiad in Informatics Final Round A とてもたのしい家庭菜園 4 的英文翻译 Growing Vegetables is Fun 4](https://www.ioi-jp.org/joi/2020/2021-ho/2021-ho-t1-en.pdf)。

# 实现
## 思路
- 先对数组进行差分
- 枚举`[1~k]`$<1$的数，并且统计矫正它们总共需要的和`l_sum`，枚举`(k~n-1]`$>-1$的数，并且统计矫正他们总共需要的和`r_sum`，`max(l_sum, r_sum)`就是`k`时的最少操作数
- 因为要枚举k，对每个k都要枚举一次最少操作数，复杂度为$o(n^2)$，**需要优化**

- 通过**前缀和**来处理`l_sum`，避免每次枚举`k`都要重新遍历整个数组计算`l_sum`；同理通过后缀和来处理`r_sum`，这样只要知道`k`就可以快速得到对应的`l_sum`和`r_sum`，把复杂度优化到$O(n)$

## 代码
```Cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
  int n;
  cin >> n;
  vector<long long> a(n);
  for(auto &x : a) cin >> x;
  vector<long long> diff(n + 2);
  adjacent_difference(a.begin(), a.end(), diff.begin() + 1);
  vector<long long> leftSum(n + 2);
  vector<long long> rightSum(n + 2);
  partial_sum(diff.begin(), diff.end(), leftSum.begin(), [](long long prev, long long cur){
    if (cur > 0) return prev;
    return prev + (-cur + 1);
  });
  partial_sum(diff.rbegin(), diff.rend(), rightSum.rbegin(), [](long long prev, long long cur){
    if (cur < 0) return prev;
    return prev + (cur + 1);
  });
  long long min_step = LLONG_MAX;
  for(int k = 1; k <= n; k++) {
    min_step = min(min_step, max(leftSum[k], rightSum[k + 1]));
  }
  
  cout << min_step << endl;
}
```


## NOTE
> [!Note] **预处理降低复杂度**
> - 注意到枚举`k`时，每一个`k`都要从头到尾遍历数组`diff`来计算`l_sum`和`r_sum`
> - 可以想到通过**前缀和预处理**的方式来避免这样不必要的重复计算
> - 通过**前缀和**来处理`l_sum`，避免每次枚举`k`都要重新遍历整个数组计算`l_sum`；同理通过**后缀和**来处理`r_sum`，这样只要知道`k`就可以快速得到对应的`l_sum`和`r_sum`
> - 为什么`r_sum`用**后缀和**：只需要访问后缀和数组`rightSum[k+1]`就可以快速得到`k`**以后**的“和”

