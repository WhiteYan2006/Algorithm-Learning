---
date: 2025-07-25
tags:
  - 编程
  - 算法
  - Cpp
  - 习题
  - 差分
  - 枚举
---
# 问题描述
在库存管理系统中，跟踪和调节商品库存量是关键任务之一。小蓝经营的仓库中存有多种商品，这些商品根据类别和规格被有序地分类并编号，编号范围从 $1$ 至 $n$。初始时，每种商品的库存量均为 $0$。

为了高效地监控和调整库存量，小蓝的管理团队设计了 $m$ 个操作，每个操作涉及到一个特定的商品区间，即一段连续的商品编号范围（例如区间 $[L, R]$）。执行这些操作时，区间内每种商品的库存量都将增加 $1$。然而，在某些情况下，管理团队可能会决定不执行某些操作，使得这些操作涉及的商品区间内的库存量不会发生改变，维持原有的状态。

现在，管理团队需要一个评估机制，来确定如果某个操作未被执行，那么最终会有多少种商品的库存量为 $0$。对此，请你为管理团队计算出，每个操作未执行时，库存量为 $0$ 的商品的种类数。

### 输入格式
第一行包含两个整数 $n$ 和 $m$，分别表示商品的种类数和操作的个数。

接下来的 $m$ 行，每行包含两个整数 $L$ 和 $R$，表示一个操作涉及的商品区间。

### 输出格式
输出共 $m$ 行，每行一个整数，第 $i$ 行的整数表示如果不执行第 $i$ 个操作，则最终库存量为 $0$ 的商品种类数。

### 样例输入
```
5 3
1 2
2 4
3 5
```

### 样例输出
```
1
0
1
```

# 实现
## 思路
- 先差分再进行前缀和得到m次操作后的数组，然后对每一次第i次操作的区间，统计区间里的`1`的个数和整个区间里0的个数，从而快速得到第i次操作撤销后有多少0
## 代码
```C++
#include<bits/stdc++.h>
using namespace std;
int main() {
  int n, m;
  cin >> n >> m;
  vector<pair<int, int>> range(m);
  vector<long long> cnt(n + 2);
  for(auto &[l, r] : range) {
    cin >> l >> r;
    cnt[l]++;
    cnt[r - 1]--;
  }
  partial_sum(cnt.begin(), cnt.end(), cnt.begin());
  vector<int> ones(n + 2); // 利用自定义前缀和统计1数量的存放数组
  int zero = 0; // 统计0的数量
  partial_sum(cnt.begin(), cnt.end() - 1, ones.begin(), [&](int prev, int cur){
    if (cur == 0) zero++; // 顺手统计0出现总数
    if (cur == 1) return prev + 1; // 前缀数组统计区间内1出现次数
    return prev;
  });
  for(auto &[l, r]: range) { // 范围循环轻松获取区间内信息
    cout << (ones[r] - ones[l - 1]) + zero << endl;
  }
}
```

## NOTE

> [!NOTE] pair数组的范围循环快速输入
> ```Cpp
> for(auto &[l, r] : range) {
>   cin >> l >> r;
> }
> ```

> [!important] 利用前缀和统计区间内某个数字出现的次数总和（以题目中的1举例）
> ```Cpp
> int zero = 0; // 统计0的数量
> partial_sum(cnt.begin(), cnt.end() - 1, ones.begin(), [&](int prev, int cur){
>   if (cur == 0) zero++;
>   if (cur == 1) return prev + 1;
>   return prev;
> });
> ``` 
> - 当`cur`是1的时候，内部匿名函数返回`prev + 1`，前缀和结束之后，`ones`数组的每个位置都是其前面1出现的次数总和
> - 顺手把zero统计了
> - 终点设置为`cnt.end() - 1`防止0被多统计






