---
date: 2026-02-09
tags:
  - 编程
  - Cpp
  - 算法
  - 习题
  - 差分
  - 二维差分
  - 枚举
---
# P6070 『MdOI R1』Decrease

## 题目描述

给定一个 $n \times n$ 的矩阵，你可以进行若干次操作。

每次操作，你可以将一个 $k \times k$ 的 **连续** 子矩阵里的所有数全都加上 $1$ 或者全都减去 $1$。

初始时，矩阵中有 $m$ 个位置上的数不为 $0$，其它位置上的数均为 $0$。

请你求出至少需要多少次操作，可以将矩形中所有数都变为 $0$。

## 输入格式

第一行三个整数 $n,m,k$，分别表示矩阵大小，非 $0$ 格数和每次修改的连续子矩阵大小。

接下来 $m$ 行，每行三个整数 $x,y,z$，表示初始时矩阵的第 $x$ 行第 $y$ 列上的数为 $z$。

## 输出格式

一行一个整数，表示最少操作次数。

特别地，如果无法使矩阵中所有数都变为 $0$，输出 `-1`。

## 输入输出样例 #1

### 输入 #1

```
4 14 3
1 1 1
1 2 1
1 3 1
2 1 1
2 2 3
2 3 3
2 4 2
3 1 1
3 2 3
3 3 3
3 4 2
4 2 2
4 3 2
4 4 2

```

### 输出 #1

```
3

```

## 输入输出样例 #2

### 输入 #2

```
3 1 2
1 1 1

```

### 输出 #2

```
-1

```

## 输入输出样例 #3

### 输入 #3

```
4 5 1
1 1 5
2 2 -3
2 3 -4
3 3 1
4 4 2

```

### 输出 #3

```
15

```

## 说明/提示

【样例 1 解释】:  

给出的矩阵为：  

```plain
1 1 1 0
1 3 3 2
1 3 3 2
0 2 2 2
```

具体步骤：  

先将以第一行第一列为左上角的连续子矩阵执行 **减 1 操作** 一次；

再将以第二行第二列为左上角的连续子矩阵执行 **减 1 操作** 两次。

总共三次。

```plain
1 1 1 0  0 0 0 0  0 0 0 0  0 0 0 0
1 3 3 2  0 2 2 2  0 1 1 1  0 0 0 0
1 3 3 2  0 2 2 2  0 1 1 1  0 0 0 0
0 2 2 2  0 2 2 2  0 1 1 1  0 0 0 0
```

【样例 2 解释】：  

给出的矩阵为：  

```plain
1 0 0
0 0 0
0 0 0
```

只通过 $2\times 2$ 的连续子矩阵操作不可能使得所有格子上的数都变为 $0$。

【数据范围】   

**本题采用捆绑测试。**

| 子任务编号 |    $n\leq$     | $k\leq$ | 分值 |
| :--------: | :------------: | :-----: | :--: |
|     1      |     $10^3$     |   $1$   |  11  |
|     2      |      $20$      |  $20$   |  14  |
|     3      |     $100$      |  $100$  |  17  |
|     4      |     $10^3$     | $10^3$  |  34  |
|     5      | $5\times 10^3$ | $10^3$  |  24  |

对于所有数据，$1\leq n\leq 5\times 10^3$，$1\leq m\leq \min(n^2,5\times 10^5)$，$1\leq k\leq \min(n,10^3)$，$1\leq x,y\leq n$，每对 $(x,y)$ 至多出现一次，$1 \le |z| \leq 10^9$。

数据保证如果有解，答案不超过 $2^{63}-1$。

---

【提示】

本题读入量较大，建议使用较快的读入方式。

# 实现

## 思路
- 先二维差分
- 从左上角往右下角遍历，遇到一个非零数就在差分数组上进行$k \cdot k$的操作
	- 比如遇到`Arr[i][j]=5`，就进行`Arr[i][j] -=5;Arr[i+k][j]+=5;Arr[i][j+k]+=5;Arr[i+k][j+k]-=5;`的操作
- 最后如果有格子不为零且没办法通过相应变化变成零，则不能做到

## 代码
```Cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
  int n, m, k;
  scanf("%d %d %d", &n, &m, &k);
  auto arr = vector(n + 2, vector(n + 2, 0ll));
  for (int i = 0; i < m; i++) {
    long long x, y, z;
    scanf("%lld %lld %lld", &x, &y, &z);
    arr[x][y] += z;
  }

  for (int i = n; i >= 1; i--) {  // 二维差分
    for (int j = n; j >= 1; j--) {
      arr[i][j] -= arr[i - 1][j];
    }
    adjacent_difference(arr[i].begin(), arr[i].end(), arr[i].begin());
  }

  long long sum = 0;
  for (int i = 1; i <= n; i++) {  // 左上角到右下角遍历
    for (int j = 1; j <= n; j++) {
      if (arr[i][j]) {                         // 遇到非零元素
        if (i + k > n + 1 || j + k > n + 1) {  // 越界所以不可能操作
          cout << -1 << endl;
          return 0;
        }
        sum += abs(arr[i][j]);
        arr[i + k][j] -= (-arr[i][j]);
        arr[i][j + k] -= (-arr[i][j]);
        arr[i + k][j + k] += (-arr[i][j]);
        arr[i][j] += (-arr[i][j]);
      }
    }
  }
  cout << sum << endl;
}
```

## NOTE
 > [! important] 为什么不用判断是否存在**“某个小区间非零，但是这个区间小于$k \times k$导致无法变为0“**
 > - 在左上角向右下角遍历的过程中，差分数组中的非零元素**会被往右下方”赶“**,即左上的元素都会变成零，右下的元素因为被操作而发生变化
 > - 所以这些”小区间“的信息在差分数组中会**逐渐往右下方”移动“**,最后**区间小于$k \times k$这一信息会被转化成`i + k > n + 1 || j + k > n + 1`的越界条件**
 
 