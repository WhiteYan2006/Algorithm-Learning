---
date: 2025-07-18
tags:
  - 编程
  - Cpp
  - 算法
  - 枚举
  - 枚举优化
  - 习题
---

# P1149 [NOIP 2008 提高组] 火柴棒等式

## 题目描述

给你 $n$ 根火柴棍，你可以拼出多少个形如 $A+B=C$ 的等式？等式中的 $A$、$B$、$C$ 是用火柴棍拼出的整数（若该数非零，则最高位不能是 $0$）。用火柴棍拼数字 $0\sim9$ 的拼法如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/p5hsawt2.png)

注意：

1. 加号与等号各自需要两根火柴棍；
2. 如果 $A\neq B$，则 $A+B=C$ 与 $B+A=C$ 视为不同的等式（$A,B,C\geq0$）；
3. $n$ 根火柴棍必须全部用上。

## 输入格式

一个整数 $n(1 \leq n\leq 24)$。

## 输出格式

一个整数，能拼成的不同等式的数目。

## 输入输出样例 #1

### 输入 #1

```
14
```

### 输出 #1

```
2
```

## 输入输出样例 #2

### 输入 #2

```
18
```

### 输出 #2

```
9
```

## 说明/提示

【输入输出样例 1 解释】

$2$ 个等式为 $0+1=1$ 和 $1+0=1$。

【输入输出样例 2 解释】

$9$ 个等式为

$0+4=4$、$0+11=11$、$1+10=11$、$2+2=4$、$2+7=9$、$4+0=4$、$7+2=9$、$10+1=11$、$11+0=11$。

noip2008 提高第二题

# 实现

## 思路
- 先确定上界，出去加号和等号，最多剩余20个火柴 
	- $a = 1111,b=1,c=1112$此时已经越界，令1111为a和b的大致的上界，限定次数**优化枚举**
- 分别枚举a和b

## 代码
```C++
#include<bits/stdc++.h>
using namespace std;
int main() {
  int stick[10] = {6,2,5,5,4,5,6,3,7,6};
  auto cnt = [&](int x) {
    if(x==0) return 6;

    int ret = 0;
    for (;x;x/=10) ret+=stick[x%10];
    return ret;

  };
  int limit = 1111; // a or b 的大致的上界
  int n;
  cin >> n;
  n -= 4;
  int ans = 0;
  for (int a = 0; a <= limit ; a++) {
    for (int b = 0; b <= limit; b++) {
      int c = a+b;
      if (cnt(a)+cnt(b)+cnt(c)==n) ans++;
    }
  }
  cout << ans << endl;
}
```
- 注：在时间限制不紧张的情况下，枚举时最好不用对称处理，很容易写错