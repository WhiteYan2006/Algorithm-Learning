---
date: 2025-07-25
tags:
  - 编程
  - 算法
  - Cpp
  - 习题
  - 差分
  - 枚举
---
# 问题描述
在库存管理系统中，跟踪和调节商品库存量是关键任务之一。小蓝经营的仓库中存有多种商品，这些商品根据类别和规格被有序地分类并编号，编号范围从 $1$ 至 $n$。初始时，每种商品的库存量均为 $0$。

为了高效地监控和调整库存量，小蓝的管理团队设计了 $m$ 个操作，每个操作涉及到一个特定的商品区间，即一段连续的商品编号范围（例如区间 $[L, R]$）。执行这些操作时，区间内每种商品的库存量都将增加 $1$。然而，在某些情况下，管理团队可能会决定不执行某些操作，使得这些操作涉及的商品区间内的库存量不会发生改变，维持原有的状态。

现在，管理团队需要一个评估机制，来确定如果某个操作未被执行，那么最终会有多少种商品的库存量为 $0$。对此，请你为管理团队计算出，每个操作未执行时，库存量为 $0$ 的商品的种类数。

### 输入格式
第一行包含两个整数 $n$ 和 $m$，分别表示商品的种类数和操作的个数。

接下来的 $m$ 行，每行包含两个整数 $L$ 和 $R$，表示一个操作涉及的商品区间。

### 输出格式
输出共 $m$ 行，每行一个整数，第 $i$ 行的整数表示如果不执行第 $i$ 个操作，则最终库存量为 $0$ 的商品种类数。

### 样例输入
```
5 3
1 2
2 4
3 5
```

### 样例输出
```
1
0
1
```

# 实现
## 思路
- 先差分再进行前缀和得到m次操作后的数组，然后对每一次第i次操作的区间，统计区间里的`1`的个数和整个区间里0的个数，从而快速得到第i次操作撤销后有多少0
## 代码
```C++
#include <bits/stdc++.h>
using namespace std;
int main() {
  int n, m;
  cin >> n >> m;
  vector<int> goods(n + 2);
  vector<int> left(m),right(m);
  for (int i = 0; i < m; i++) {
    cin >> left[i] >> right[i];
    goods[left[i]]++;
    goods[right[i] + 1]--;
  }
  partial_sum(goods.begin(),goods.end(),goods.begin());
  int numbers_of_zero = 0;
  for (int i =1; i <= n; i++) {
    if (goods[i]==0) numbers_of_zero++;
  }
  for (int i =1; i <= m; i++) {
    int numbers_of_one = 0;
    for (int j = left[i-1]; j <= right[i-1]; j++) {
      if (goods[j]==1) numbers_of_one++;
    }
    cout << numbers_of_one+numbers_of_zero << endl;
  }
}
```
