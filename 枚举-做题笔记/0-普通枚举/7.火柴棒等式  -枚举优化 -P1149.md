---
date: 2025-07-18
tags:
  - 编程
  - Cpp
  - 算法
  - 枚举
  - 枚举优化
  - 习题
---

# P1149 [NOIP 2008 提高组] 火柴棒等式

## 题目描述

给你 $n$ 根火柴棍，你可以拼出多少个形如 $A+B=C$ 的等式？等式中的 $A$、$B$、$C$ 是用火柴棍拼出的整数（若该数非零，则最高位不能是 $0$）。用火柴棍拼数字 $0\sim9$ 的拼法如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/p5hsawt2.png)

注意：

1. 加号与等号各自需要两根火柴棍；
2. 如果 $A\neq B$，则 $A+B=C$ 与 $B+A=C$ 视为不同的等式（$A,B,C\geq0$）；
3. $n$ 根火柴棍必须全部用上。

## 输入格式

一个整数 $n(1 \leq n\leq 24)$。

## 输出格式

一个整数，能拼成的不同等式的数目。

## 输入输出样例 #1

### 输入 #1

```
14
```

### 输出 #1

```
2
```

## 输入输出样例 #2

### 输入 #2

```
18
```

### 输出 #2

```
9
```

## 说明/提示

【输入输出样例 1 解释】

$2$ 个等式为 $0+1=1$ 和 $1+0=1$。

【输入输出样例 2 解释】

$9$ 个等式为

$0+4=4$、$0+11=11$、$1+10=11$、$2+2=4$、$2+7=9$、$4+0=4$、$7+2=9$、$10+1=11$、$11+0=11$。

noip2008 提高第二题

# 实现

## 思路
- 先确定上界，出去加号和等号，最多剩余20个火柴 
	- $a = 1111,b=1,c=1112$此时已经越界，令1111为a和b的大致的上界，限定次数**优化枚举**
- 两重循环枚举a和b，判断`a,b,c`所需要的木棍是否刚好等于剩余木棍

## 代码
```C++
#include<bits/stdc++.h>
using namespace std;
int sticks[] = {6, 2, 5 ,5, 4, 5, 6, 3, 7, 6};
int main() {
  int n;
  cin >> n;
  n -= 4; // +和= 需要四根，减去
  auto needHowManyStick = [](int x) {
    if (x == 0) return 6; // 处理x=0的特殊情况
    int res = 0;
    for (; x; x/= 10) {
      res += sticks[x % 10];
    }
    return res;
  };
  int cnt = 0;
  // 1111 + 1 = 1112 -> 1111就是a大概的上界
  for (int a = 0; a < 1111; a++) { // a 的上界大概是1111
    int stickLeft = n; // 统计还剩几根棍子
    for (int b = 0; b < 1111; b++) {
      int c = a + b;
      if (needHowManyStick(a) + needHowManyStick(b) + needHowManyStick(c) == stickLeft) cnt++;
    }
  }
  cout << cnt << endl;
}
```
- 注：在时间限制不紧张的情况下，枚举时最好不用对称处理，很容易写错