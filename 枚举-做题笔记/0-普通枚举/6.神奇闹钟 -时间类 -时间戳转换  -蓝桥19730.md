---
date: 2025-07-18
tags:
  - 编程
  - 蓝桥杯
  - Cpp
  - 算法
  - 枚举
  - 时间类
  - 时间戳转换
  - 习题
---
### 问题描述

小蓝发现了一个神奇的闹钟，从纪元时间（1970 年 1 月 1 日 00：00：000）开始，每经过 x 分钟，这个闹钟便会触发一次闹铃 (纪元时间也会响铃)。这引起了小蓝的兴趣，他想要好好研究下这个闹钟。

对于给出的任意一个格式为 уууу-MM-ddHH:mm:ss 的时间，小蓝想要知道在这个时间点之前 (包含这个时间点) 的最近的一次闹铃时间是哪个时间?

注意，你不必考虑时区问题。

### 输入格式

输入的第一行包含一个整数 T，表示每次输入包含 T 组数据。

接下来依次描述 T 组数据。

每组数据一行，包含一个时间（格式为 уууу-MM-ddHH:mm:ss）和一个整数 x，其中 x 表示闹铃时间间隔（单位为分钟）。

### 输出格式

输出 T 行，每行包含一个时间（格式为 уууу-MM-ddHH:mm:ss），依次表示每组数据的答案。

### 样例输入

```text
2
2016-09-07 18:24:33 10
2037-01-05 01:40:43 30
```

### 样例输出

```text
2016-09-07 18:20:00
2037-01-05 01:30:00
```

### 评测用例规模与约定

对于所有评测用例，1≤T≤10,1≤x≤1000，保证所有的时间格式都是合法的。


# 实现

## 思路
- 将$x$化为秒数
- 获取给定时间到1970-1-1 00:00:00的秒数$time$，然后用$x$整除$time$得到响铃次数，再乘以$time$就是最近一次响铃的时间->$time//t*t$
- 再将得到的秒数转化成对应时间格式
	- 日期->时间戳 / 时间戳->日期

## 代码
```C++
#include <iostream>
using namespace std;
int main() {
  int dayInMonths[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
  auto isLeapYear = [](int y) {
    return y % 4 == 0 && y % 100 != 0 || y % 400 == 0;
  };
  auto dateToStamp = [&](int y, int m, int d, int h, int mm, int s) {
    long long res = 0;
    int secondInDay = 24 * 60 * 60;
    for (int i = 1970; i < y; i++) {  // 按年
      res += (365 + isLeapYear(i)) * secondInDay;
    }
    for (int i = 1; i < m; i++) {  // 按月
      res += (dayInMonths[i] + (i == 2 && isLeapYear(y))) * secondInDay;  // 要判断闰年影响
    }
    res += (d - 1) * secondInDay;
    res += h * 60 * 60;
    res += mm * 60;
    res += s;
    return res;
  };
  auto timestampToDate = [&](long long timestamp) {  // 取模运算
    int secondInDay = 24 * 60 * 60;
    int s = timestamp % 60;
    int mm = timestamp % 3600 / 60;          // 计算分钟的方法
    int h = timestamp % (3600 * 24) / 3600;  // 计算小时
    int days = timestamp / secondInDay;
    int y = 1970, m = 1;

    for (;; y++) {  // 获取年份
      int dayInYear = 365 + isLeapYear(y);
      if (days >= dayInYear)
        days -= dayInYear;
      else
        break;
    }

    for (;; m++) {
      int dayInMonth = dayInMonths[m] + (m == 2 && isLeapYear(y));
      if (days >= dayInMonth)
        days -= dayInMonth;
      else
        break;
    }
    int d = days + 1;
    printf("%04d-%02d-%02d %02d:%02d:%02d\n", y, m, d, h, mm, s);
  };
  int t;
  cin >> t;
  while (t--) {
    int y, m, d, h, mm, s, x;
    scanf("%d-%d-%d %d:%d:%d %d", &y, &m, &d, &h, &mm, &s, &x);
    x *= 60;
    long long timestamp = dateToStamp(y, m, d, h, mm, s);  // 转换为时间戳
    timestamp = timestamp / x * x;  // 整除x后再乘x得到上一次响铃的时间戳
    timestampToDate(timestamp);     // 再将得到的时间戳转换为日期
  }
  return 0;
}
```