---
date: 2025-07-23
tags:
  - 编程
  - 算法
  - 枚举
  - 枚举优化
  - STL
  - 前缀和
  - 习题
  - Cpp
---
### 问题描述
小明是学校里的一名老师，他带的班级共有 $n$ 名同学，第 $i$ 名同学力量值为 $a_i$。在闲暇之余，小明决定在班级里组织一场拔河比赛。

为保证比赛的双方实力尽可能相近，需要在这 $n$ 名同学中挑选出两个队伍，队伍内的同学编号连续：$\{a_{l_1}, a_{l_1 + 1}, \dots, a_{r_1 - 1}, a_{r_1}\}$ 和 $\{a_{l_2}, a_{l_2 + 1}, \dots, a_{r_2 - 1}, a_{r_2}\}$，其中 $l_1 \leq r_1 < l_2 \leq r_2$。

两个队伍的人数不必相同，但是需要让队伍内的同学们的力量值之和尽可能相近。请计算出力量值之和差距最小的挑选队伍的方式。

### 输入格式
输入共两行。

第一行为一个正整数 $n$。

第二行为 $n$ 个正整数 $a_i$。

### 输出格式
输出共一行，一个非负整数，表示两个队伍力量值之和的最小差距。

### 样例输入
```
5
10 9 8 12 14
```

### 样例输出
```
1
```

### 样例说明
其中一种最优选择方式：
队伍 1：$\{a_1, a_2, a_3\}$，队伍 2：$\{a_4, a_5\}$，力量值和分别为 $10 + 9 + 8 = 27$，$12 + 14 = 26$，差距为 $|27 - 26| = 1$。

### 评测用例规模与约定
对于 $20\%$ 的评测用例，保证 $n \leq 50$。

对于 $100\%$ 的评测用例，保证 $n \leq 10^3$，$a_i \leq 10^9$。
# 实现
## 思路
![[Pasted image 20250723092656.png]]
- 对于此类枚举一般都是先枚举中间内容，本题选择从r1开始枚举
- 在r1后所有l2到r2的和，可以维护一个数据结构`S(l2,r2)`，因为只需要求得最小值，所以选择`set`的数据结构来维护，可以极大减少复杂度
- 由原本暴力枚举的$O(n^4)$复杂度变成枚举r1$O(n)$，维护`S(l2,r2)`$O(n\log n)$，枚举l1后进行前缀和$O(n)$，通过lower_bound查找$O(n\log n)$，总计$O(n(n\log n+n\log n))\to O(n^{2}\log n)$
## 代码
```C++
#include <bits/stdc++.h>
using namespace std;
int main() {
  int n;
  cin >> n;
  vector<long long> a(n);
  for (auto &x : a) cin >> x;
  vector<long long> sum(n + 1);
  partial_sum(a.begin(), a.end(), sum.begin() + 1);  // +1防止数组越界
  auto ans = LLONG_MAX;                              // 最大的longlong
  set<long long> s;
  for (int r = n - 1; r >= 1; r--) {
    for (int x = r + 1; x <= n; x++) {  // 维护集合s(r2,l2)，这样就避免了还要再次对r2，l2的枚举，把所有r2到l2的和存起来
      s.insert(sum[x] - sum[r]);
    }
    for (int l = 1; l <= r; l++) {
      auto target = sum[r] - sum[l - 1];
      auto iter = s.lower_bound(target);  // 找到第一个>=target的数字
      if (iter != s.end()) {  // 没找到会返回s.end(),判断是否找到
        ans = min(ans, *iter - target);
      }
      if (iter != s.begin()) {
        --iter;  // 迭代器的--最好放在前面，性能更高
        ans = min(ans,target - *iter);  // 通过迭代器向前一位找到最近的<target的数，从而满足绝对值条件
      }
    }
  }
  cout << ans << endl;
  return 0;
}
```